import {
  AirflowDAGTaskType,
  EtlEngine,
  EtlType,
  ExportTool,
  ExportType,
  ExportValidationMethod,
  ImportTool,
  ImportType,
  SettingType,
  ValidationMethod
} from './enums'
import {
  AirflowTask,
  Columns,
  Connection,
  CustomAirflowDAG,
  EditSetting,
  ExportAirflowDAG,
  ExportColumns,
  ImportAirflowDAG,
  UiDbTable,
  UIExportCnTables,
  UIExportTable,
  UITable
} from './interfaces'
import infoTexts from '../infoTexts.json'
import { getEnumOptions, mapDisplayValue } from './nameMappings'

export function airflowCardRenderSettings(
  airflowType: 'import' | 'export' | 'custom',
  dagData: ImportAirflowDAG | ExportAirflowDAG | CustomAirflowDAG
) {
  const baseAirflowDagSettings: EditSetting[] = [
    {
      label: 'DAG Name',
      value: dagData.name,
      type: SettingType.Readonly,
      infoText: infoTexts.airflow[airflowType].name
    }, // Readonly, varchar(64), have to be unique across import, export and custom, required
    {
      label: 'Schedule Interval',
      value: dagData.scheduleInterval,
      type: SettingType.Text,
      infoText: infoTexts.airflow[airflowType].scheduleInterval
    }, // Free-text, Time to execute DAG, varchar(128), required

    {
      label: 'Retries',
      value: dagData.retries,
      type: SettingType.IntegerFromZero,
      infoText: infoTexts.airflow[airflowType].retries
    }, // Integer, tinyint(4), default value: 5 for import & export and 0 for custom, How many retries should be Task do in Airflow before it failes,  required
    {
      label: 'Operator Notes',
      value: dagData.operatorNotes,
      type: SettingType.Textarea,
      infoText: infoTexts.airflow[airflowType].operatorNotes
    }, // Free-text (64k)
    {
      label: 'Application Notes',
      value: dagData.applicationNotes,
      type: SettingType.Textarea,
      infoText: infoTexts.airflow[airflowType].applicationNotes
    }, // Free-text (64k)
    {
      label: 'Auto Regenerate DAG',
      value: dagData.autoRegenerateDag,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].autoRegenerateDag
    }, // Boolean, if not set pre-set default value: 1, 1 = The DAG will be auto regenerated by manage command, required
    {
      label: 'Airflow Notes',
      value: dagData.airflowNotes,
      type: SettingType.Textarea,
      infoText: infoTexts.airflow[airflowType].airflowNotes
    }, // Free-text (64k)
    {
      label: 'Sudo User',
      value: dagData.sudoUser,
      type: SettingType.Text,
      infoText: infoTexts.airflow[airflowType].sudoUser
    }, // Free-text, varchar(64), All tasks in DAG will use this user for sudo instead of default
    {
      label: 'Timezone',
      value: dagData.timezone,
      type: SettingType.TimeZone,
      infoText: infoTexts.airflow[airflowType].timezone
    }, // Timezone,, varchar(64), used for schedule_interval column. Use full text timezone, example Europe/Stockholm
    {
      label: 'Email',
      value: dagData.email,
      type: SettingType.Email,
      infoText: infoTexts.airflow[airflowType].email,
      isConditionsMet:
        dagData.emailOnRetries === true || dagData.emailOnFailure === true
    }, // Free-text, varchar(256), Email to send message to in case email_on_retry or email_on_failure is set to True
    {
      label: 'Email On Failure',
      value: dagData.emailOnFailure ? dagData.emailOnFailure : false,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].emailOnFailure
    }, // Boolean, if not set pre-set default value: false, Send email on failures, required
    {
      label: 'Email On Retries',
      value: dagData.emailOnRetries ? dagData.emailOnRetries : false,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].emailOnRetries
    }, // Boolean, if not set pre-set default value: false, Send email on retries, required
    {
      label: 'Tags',
      value: dagData.tags,
      type: SettingType.Text,
      infoText: infoTexts.airflow[airflowType].tags
    }, // Free-text, varchar(256), Comma seperated list of Airflow tags that will be set on the DAG
    {
      label: 'Sla Warning Time',
      value: dagData.slaWarningTime,
      type: SettingType.Time,
      infoText: infoTexts.airflow[airflowType].slaWarningTime
    }, // Time, Maximum time this DAG should run before Airflow triggers a SLA miss
    {
      label: 'Retry Exponential Backoff',
      value: dagData.retryExponentialBackoff
        ? dagData.retryExponentialBackoff
        : false,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].retryExponentialBackoff
    }, // Boolean, if not set pre-set default value: false, true=Use the retry_exponential_backoff Airflow function that will cause the retry between failed tasks to be longer and longer each time instead of a fixed time, false=Run with a fixed time of 5 min between the task retries, required
    {
      label: 'Concurrency',
      value: dagData.concurrency,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.airflow[airflowType].concurrency
    } // Integer, tinyint(4), Set the max Integer of concurrent tasks in the DAG while executing. Overrides the default value specified in Airflow configuration
  ]

  const airflowImportDagSettings: EditSetting[] =
    'filterTable' in dagData
      ? [
          {
            label: 'Filter Table',
            value: dagData.filterTable, // column filter_hive in db
            type: SettingType.Textarea,
            infoText: infoTexts.airflow.import.filterTable
          }, // Free-text, varchar(16384), Filter string for database and table. ; separated. Wildcards (*) allowed. Example HIVE_DB.HIVE_TABLE; HIVE_DB.HIVE_TABLE, required
          {
            label: 'Finish all Stage 1 first',
            value: dagData.finishAllStage1First,
            type: SettingType.Boolean,
            infoText: infoTexts.airflow.import.finishAllStage1First
          }, // Boolean, if not set pre-set default value: false, true=All Import phase jobs will be completed first, and when all is successfull, the ETL phase start, required
          {
            label: 'Retries Import Stage',
            value: dagData.retriesStage1,
            type: SettingType.IntegerFromOneOrNull,
            infoText: infoTexts.airflow.import.retriesStage1
          }, // Integer, tinyint(4), Specific retries Integer for Import Phase
          {
            label: 'Retries ETL Stage',
            value: dagData.retriesStage2,
            type: SettingType.IntegerFromOneOrNull,
            infoText: infoTexts.airflow.import.retriesStage2
          }, // Integer, tinyint(4), Specific retries Integer for Import Phase
          {
            label: 'Pool Import Stage',
            value: dagData.poolStage1,
            type: SettingType.Text,
            infoText: infoTexts.airflow.import.poolStage1
          }, // Free-text, varchar(256), Airflow pool used for stage1 tasks. NULL for the default Hostname pool
          {
            label: 'Pool ETL Stage',
            value: dagData.poolStage2,
            type: SettingType.Text,
            infoText: infoTexts.airflow.import.poolStage2
          }, // Free-text, varchar(256), Airflow pool used for stage2 tasks. NULL for the default DAG pool
          {
            label: 'Run Only Metadata Import',
            value: dagData.metadataImport,
            type: SettingType.Boolean,
            infoText: infoTexts.airflow.import.metadataImport
          }, // Boolean, if not set pre-set default value: false, required
          {
            label: 'Run Import and Etl separate',
            value: dagData.runImportAndEtlSeparate,
            type: SettingType.Boolean,
            infoText: infoTexts.airflow.import.runImportAndEtlSeparate
          } // Boolean, if not set pre-set default value: true, required
        ]
      : []

  const airflowExportDagSettings: EditSetting[] =
    'filterConnection' in dagData
      ? [
          {
            label: 'Filter Connection',
            value: dagData.filterConnection, // column filter_hive in db
            type: SettingType.Text,
            infoText: infoTexts.airflow.export.filterConnection
          }, // Free-text, varchar(256), Filter string for DBALIAS in export_tables, required
          {
            label: 'Filter Target Schema',
            value: dagData.filterTargetSchema,
            type: SettingType.Text,
            infoText: infoTexts.airflow.export.filterTargetSchema
          }, // Free-text, varchar(256), Filter string for TARGET_SCHEMA  in export_tables
          {
            label: 'Filter Target Table',
            value: dagData.filterTargetTable,
            type: SettingType.Text,
            infoText: infoTexts.airflow.export.filterTargetTable
          } // Free-text, varchar(256), Filter string for TARGET_TABLE  in export_tables
        ]
      : []

  const airflowCustomDagSettings: EditSetting[] = baseAirflowDagSettings

  let combinedAirflowDagSettings

  switch (airflowType) {
    case 'import':
      return (combinedAirflowDagSettings = [
        ...baseAirflowDagSettings,
        ...airflowImportDagSettings
      ])
    case 'export':
      return (combinedAirflowDagSettings = [
        ...baseAirflowDagSettings,
        ...airflowExportDagSettings
      ])
    case 'custom':
      return (combinedAirflowDagSettings = airflowCustomDagSettings)
  }

  return combinedAirflowDagSettings
}

export function createAirflowSettings(
  airflowType: 'import' | 'export' | 'custom'
) {
  const baseAirflowDagSettings: EditSetting[] = [
    {
      label: 'DAG Name',
      value: null,
      type: SettingType.Text,
      infoText: infoTexts.airflow[airflowType].name
    }, //Free-text, varchar(64), have to be unique across import, export and custom, required
    {
      label: 'Schedule Interval',
      value: null,
      type: SettingType.Text,
      infoText: infoTexts.airflow[airflowType].scheduleInterval
    }, // Free-text, Time to execute DAG, varchar(128), required
    {
      label: 'Auto Regenerate DAG',
      value: true,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].autoRegenerateDag
    } // Boolean, if not set pre-set default value: true, true = The DAG will be auto regenerated by manage command, required
  ]

  const airflowImportDagSettings: EditSetting[] = [
    {
      label: 'Filter Table',
      value: null,
      type: SettingType.Text,
      infoText: infoTexts.airflow.import.filterTable
    } // Free-text, varchar(16384), Filter string for database and table. ; separated. Wildcards (*) allowed. Example HIVE_DB.HIVE_TABLE; HIVE_DB.HIVE_TABLE, required
  ]

  const airflowExportDagSettings: EditSetting[] = [
    {
      label: 'Filter Connection',
      value: null, // column filter_hive in db
      type: SettingType.Text,
      infoText: infoTexts.airflow.export.filterConnection
    }, // Free-text, varchar(256), Filter string for DBALIAS in export_tables
    {
      label: 'Filter Target Schema',
      value: null,
      type: SettingType.Text,
      infoText: infoTexts.airflow.export.filterTargetSchema
    }, // Free-text, varchar(256), Filter string for TARGET_SCHEMA  in export_tables
    {
      label: 'Filter Target Table',
      value: null,
      type: SettingType.Text,
      infoText: infoTexts.airflow.export.filterTargetTable
    } // Free-text, varchar(256), Filter string for TARGET_TABLE  in export_tables
  ]

  const airflowCustomDagSettings: EditSetting[] = baseAirflowDagSettings

  let combinedAirflowDagSettings

  switch (airflowType) {
    case 'import':
      return (combinedAirflowDagSettings = [
        ...baseAirflowDagSettings,
        ...airflowImportDagSettings
      ])
    case 'export':
      return (combinedAirflowDagSettings = [
        ...baseAirflowDagSettings,
        ...airflowExportDagSettings
      ])
    case 'custom':
      return (combinedAirflowDagSettings = airflowCustomDagSettings)
  }

  return combinedAirflowDagSettings
}

export function airflowTaskRowDataEdit(row: AirflowTask) {
  const rowData: EditSetting[] = [
    {
      label: 'Task Name',
      value: row.name,
      type: SettingType.Readonly,
      infoText: infoTexts.airflow.tasks.name,
      isHidden: true
    }, // Hidden Readonly, have to be unique across import, export and custom, varchar(64), required
    {
      label: 'Type',
      value: mapDisplayValue('type', row.type),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('type'),
      infoText: infoTexts.airflow.tasks.type
    }, // Enum, 'shell script','Hive SQL','Hive SQL Script','JDBC SQL','Trigger DAG','DAG Sensor','SQL Sensor','DBImport command', required (default value: 'Hive SQL Script')

    {
      label: 'Placement',
      value: mapDisplayValue('placement', row.placement),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('placement'),
      infoText: infoTexts.airflow.tasks.placement
    }, // Enum, 'before main','after main','in main', required (default value: 'after main')

    {
      label: 'Connection',
      value: row.connection,
      type: SettingType.ConnectionReference,
      isConditionsMet: row.type === AirflowDAGTaskType.JDBCSQL,
      infoText: infoTexts.airflow.tasks.connection
    }, // Free-text, only active if "JDBC SQL" is selected in taskType, varchar(256)
    {
      label: 'Airflow Pool',
      value: row.airflowPool,
      type: SettingType.Readonly,
      infoText: infoTexts.airflow.tasks.airflowPool
    }, // Readonly, varchar(64)
    {
      label: 'Airflow Priority',
      value: row.airflowPriority,
      type: SettingType.Text,
      infoText: infoTexts.airflow.tasks.airflowPriority
    }, // Free-text, varchar(64)
    {
      label: 'Include In Airflow',
      value: row.includeInAirflow ? row.includeInAirflow : true,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow.tasks.includeInAirflow
    }, // Boolean true or false, required (default value: true)
    {
      label: 'Task Dependency Downstream',
      value: row.taskDependencyDownstream,
      type: SettingType.Text,
      infoText: infoTexts.airflow.tasks.taskDependencyDownstream
    }, // Free-text, Defines the downstream dependency for the Task. Comma separated list, varchar(256)
    {
      label: 'Task Dependency Upstream',
      value: row.taskDependencyUpstream,
      type: SettingType.Text,
      infoText: infoTexts.airflow.tasks.taskDependencyUpstream
    }, // Free-text, Defines the upstream dependency for the Task. Comma separated list, varchar(256)
    {
      label: 'Task Config',
      value: row.taskConfig,
      type: SettingType.Textarea,
      infoText: infoTexts.airflow.tasks.taskConfig
    }, // Free-text, The configuration for the Task. Depends on what Task type it is,, varchar(512)
    {
      label: 'Sensor Poke Interval',
      value: row.sensorPokeInterval,
      type: SettingType.IntegerFromZeroOrNull,
      infoText: infoTexts.airflow.tasks.sensorPokeInterval
    }, // Number, Poke interval for sensors in seconds, int(11)
    {
      label: 'Sensor Timeout Minutes',
      value: row.sensorTimeoutMinutes,
      type: SettingType.Readonly,
      infoText: infoTexts.airflow.tasks.sensorTimeoutMinutes
    }, // Readonly, Timeout for sensors in minutes, int(11)
    {
      label: 'Sensor Connection',
      value: row.sensorConnection,
      type: SettingType.Text,
      infoText: infoTexts.airflow.tasks.sensorConnection
    }, // Free-text, Name of Connection in Airflow, varchar(64)
    {
      label: 'Sensor Soft Fail',
      value: row.sensorSoftFail === 1 ? 1 : 0,
      type: SettingType.BooleanNumber,
      infoText: infoTexts.airflow.tasks.sensorSoftFail
    }, // Boolean number, Setting this to 1 will add soft_fail=True on sensor (1=true, all else = false), int(11)
    {
      label: 'Sudo User',
      value: row.sudoUser,
      type: SettingType.Text,
      infoText: infoTexts.airflow.tasks.sudoUser
    } // Free-text, The task will use this user for sudo instead of default, varchar(64)
  ]
  return rowData
}

// Connection

export function connectionCardRenderSettings(connection: Connection) {
  const connectionSettings: EditSetting[] = [
    // {
    //   label: 'Name',
    //   value: connection.name,
    //   type: SettingType.Text,
    //   infoText: infoTexts.connection.name
    // }, //Free-text (varchar 256)
    {
      label: 'Connection String',
      value: connection.connectionString,
      type: SettingType.Textarea,
      infoText: infoTexts.connection.connectionString
    }, // Free-text (64k)
    {
      label: 'Private Key Path',
      value: connection.privateKeyPath,
      type: SettingType.Text,
      infoText: infoTexts.connection.privateKeyPath
    }, // Free-text (varchar 128)
    {
      label: 'Public Key Path',
      value: connection.publicKeyPath,
      type: SettingType.Text,
      infoText: infoTexts.connection.publicKeyPath
    }, // Free-text (varchar 128)
    {
      label: 'Credentials',
      value: connection.credentials !== null ? connection.credentials : '',
      type: SettingType.Textarea,
      infoText: infoTexts.connection.credentials
    }, // Free-text (64k)

    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Source',
      value: connection.source,
      type: SettingType.Text,
      infoText: infoTexts.connection.source
    }, // Free-text (varchar 256)
    {
      label: 'Force String',
      value: connection.forceString,
      type: SettingType.BooleanOrDefaultFromConfig,
      infoText: infoTexts.connection.forceString
    }, // Boolean, (1, 0) or Default from Config (-1)
    {
      label: 'Max Sessions',
      value: connection.maxSessions,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.connection.maxSessions
    }, // Integer
    {
      label: 'Create Foreign Key',
      value: connection.createForeignKey,
      type: SettingType.Boolean,
      infoText: infoTexts.connection.createForeignKey
    }, // Boolean, true or false
    {
      label: 'Create Datalake Import',
      value: connection.createDatalakeImport,
      type: SettingType.Boolean,
      infoText: infoTexts.connection.createDatalakeImport
    }, // Boolean, true or false
    {
      label: 'Time Window Start',
      value: connection.timeWindowStart,
      type: SettingType.Time,
      infoText: infoTexts.connection.timeWindowStart
    }, // Time
    {
      label: 'Time Window Stop',
      value: connection.timeWindowStop,
      type: SettingType.Time,
      infoText: infoTexts.connection.timeWindowStop
    }, // Time
    {
      label: 'Time Window Timezone',
      value: connection.timeWindowTimezone,
      type: SettingType.TimeZone,
      infoText: infoTexts.connection.timeWindowTimezone
    }, // TimeZone
    {
      label: 'Seed File',
      value: connection.seedFile,
      type: SettingType.Text,
      infoText: infoTexts.connection.seedFile
    }, // Free-text (varchar 256)

    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Operator Notes',
      value: connection.operatorNotes,
      type: SettingType.Textarea,
      infoText: infoTexts.connection.operatorNotes
    }, // Free-text (64k)
    {
      label: 'Contact Information',
      value: connection.contactInformation,
      type: SettingType.Text,
      infoText: infoTexts.connection.contactInformation
    }, // Free-text (varchar 256)
    {
      label: 'Description',
      value: connection.description,
      type: SettingType.Text,
      infoText: infoTexts.connection.description
    }, // Free-text (varchar 256)
    {
      label: 'Owner',
      value: connection.owner,
      type: SettingType.Text,
      infoText: infoTexts.connection.owner
    }, // Free-text (varchar 256)
    // {
    //   label: 'Environment',
    //   value: connection.environment,
    //   type: SettingType.Text
    // }, // Free-text (varchar 256), skip this because functionality for it is not yet implemented in the system
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Atlas Discovery',
      value: connection.atlasDiscovery,
      type: SettingType.Boolean,
      infoText: infoTexts.connection.atlasDiscovery
    }, // Boolean, true or false
    {
      label: 'Atlas Include Filter',
      value: connection.atlasIncludeFilter,
      type: SettingType.Text,
      infoText: infoTexts.connection.atlasIncludeFilter
    }, // Free-text (varchar 256)
    {
      label: 'Atlas Exclude Filter',
      value: connection.atlasExcludeFilter,
      type: SettingType.Text,
      infoText: infoTexts.connection.atlasExcludeFilter
    }, // Free-text (varchar 256)
    {
      label: 'Atlas Last Discovery',
      value: connection.atlasLastDiscovery,
      type: SettingType.Readonly,
      infoText: infoTexts.connection.atlasLastDiscovery
    } // Readonly (varchar 256)
  ]
  return connectionSettings
}

// Import

export function importDbTablesEditSettings(row: UiDbTable) {
  const rowData: EditSetting[] = [
    {
      label: 'Database',
      value: row.database,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.database
    }, //Free-text, read-only, default selected db, potentially copyable?
    {
      label: 'Table',
      value: row.table,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.table
    }, // Free-text, read-only
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Import Type',
      value: mapDisplayValue('importPhaseType', row.importPhaseType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importPhaseType'),
      infoText: infoTexts.table.import.importPhaseType
    }, // Enum mapping for 'Import Type'
    {
      label: 'ETL Type',
      value: mapDisplayValue('etlPhaseType', row.etlPhaseType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlPhaseType'),
      infoText: infoTexts.table.import.etlPhaseType
    }, // Enum mapping for 'ETL Type'
    {
      label: 'Import Tool',
      value: mapDisplayValue('importTool', row.importTool),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importTool'),
      infoText: infoTexts.table.import.importTool
    }, // Enum mapping for 'Import Tool'
    {
      label: 'ETL Engine',
      value: mapDisplayValue('etlEngine', row.etlEngine),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlEngine'),
      infoText: infoTexts.table.import.etlEngine
    } // Enum mapping for 'ETL Engine'
  ]
  return rowData
}

export function importCardRenderSettings(table: UITable) {
  const mainSettings: EditSetting[] = [
    {
      label: 'Database',
      value: table.database,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.database
    }, // Read-only, default selected db, potentially copyable?
    {
      label: 'Table',
      value: table.table,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.table
    }, // Read-only
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Connection',
      value: table.connection,
      type: SettingType.ConnectionReferenceRequired,
      infoText: infoTexts.table.import.connection
    }, // Reference to /connection
    {
      label: 'Source Database Type',
      value: table.columns?.[0]?.sourceDatabaseType ?? '',
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.sourceDatabaseType
    }, // Read-only, free-text, should be displayed, from inside table.columns[]
    {
      label: 'Source Schema',
      value: table.sourceSchema,
      type: SettingType.Text,
      infoText: infoTexts.table.import.sourceSchema
    }, // Free-text
    {
      label: 'Source Table',
      value: table.sourceTable,
      type: SettingType.Text,
      infoText: infoTexts.table.import.sourceTable
    }, // Free-text
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Import Type',
      value: mapDisplayValue('importPhaseType', table.importPhaseType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importPhaseType'),
      infoText: infoTexts.table.import.importPhaseType
    }, // Enum mapping for 'Import Type'
    {
      label: 'ETL Type',
      value: mapDisplayValue('etlPhaseType', table.etlPhaseType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlPhaseType'),
      infoText: infoTexts.table.import.etlPhaseType
    }, // Enum mapping for 'ETL Type'
    {
      label: 'Import Tool',
      value: mapDisplayValue('importTool', table.importTool),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importTool'),
      infoText: infoTexts.table.import.importTool
    }, // Enum mapping for 'Import Tool'
    {
      label: 'ETL Engine',
      value: mapDisplayValue('etlEngine', table.etlEngine),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlEngine'),
      infoText: infoTexts.table.import.etlEngine
    }, // Enum mapping for 'ETL Engine'
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Last Update From Source',
      value: table.lastUpdateFromSource,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.lastUpdateFromSource
    }, // Read-only
    {
      label: 'Source Table Type',
      value: table.sourceTableType,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.sourceTableType
    }, // Read-only
    {
      label: 'Import Database',
      value: table.importDatabase,
      type: SettingType.Text,
      infoText: infoTexts.table.import.importDatabase
    }, // Free-text
    {
      label: 'Import Table',
      value: table.importTable,
      type: SettingType.Text,
      infoText: infoTexts.table.import.importTable
    }, // Free-text setting
    {
      label: 'History Database',
      value: table.historyDatabase,
      type: SettingType.Text,
      infoText: infoTexts.table.import.historyDatabase
    }, // Free-text
    {
      label: 'History Table',
      value: table.historyTable,
      type: SettingType.Text,
      infoText: infoTexts.table.import.historyTable
    } // Free-text
  ]

  const importOptions: EditSetting[] = [
    {
      label: 'Allow Text Splitter',
      value: table.allowTextSplitter,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.allowTextSplitter
    }, // Boolean, true or false
    {
      label: 'Force String',
      value: table.forceString,
      type: SettingType.BooleanOrDefaultFromConfig,
      infoText: infoTexts.table.import.forceString
    }, //  Boolean, (1, 0) or Default from Config (-1)
    {
      label: 'Split By Column',
      value: table.splitByColumn,
      type: SettingType.Text,
      infoText: infoTexts.table.import.splitByColumn
    }, // Free-text
    {
      label: 'Sqoop Options',
      value: table.sqoopOptions,
      type: SettingType.Text,
      infoText: infoTexts.table.import.sqoopOptions,
      isConditionsMet: table.importTool === ImportTool.Sqoop
    }, // Free-text, active only if importTool=sqoop
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'SQL WHERE Addition',
      value: table.sqlWhereAddition,
      type: SettingType.Text,
      infoText: infoTexts.table.import.sqlWhereAddition
    }, // Free-text
    {
      label: 'Custom Query',
      value: table.customQuery,
      type: SettingType.Text,
      infoText: infoTexts.table.import.customQuery,
      isConditionsMet: table.useGeneratedSql === false
    }, // Active only if useGeneratedSql=false
    {
      label: 'Custom Max Query',
      value: table.customMaxQuery,
      type: SettingType.Text,
      infoText: infoTexts.table.import.customMaxQuery,
      isConditionsMet: table.useGeneratedSql === false
    }, // Active only if useGeneratedSql=false
    {
      label: 'Use Generated SQL',
      value: table.useGeneratedSql,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.useGeneratedSql
    }, // Boolean, true or false
    {
      label: 'No Merge Ingestion SQL Addition',
      value: table.nomergeIngestionSqlAddition,
      type: SettingType.Text,
      infoText: infoTexts.table.import.nomergeIngestionSqlAddition
    }, // Free-text setting (nmore information might come about this one)
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Last Size',
      value: table.lastSize,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.lastSize
    }, // Read-only
    {
      label: 'Last Rows',
      value: table.lastRows,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.lastRows
    }, // Read-only
    {
      label: 'Last Mappers',
      value: table.lastMappers,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.lastMappers
    }, // Read-only
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Generated Hive Column Definition',
      value: table.generatedHiveColumnDefinition,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.generatedHiveColumnDefinition
    }, // Read-only
    {
      label: 'Generated Sqoop Query',
      value: table.generatedSqoopQuery,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.generatedSqoopQuery
    }, // Read-only
    {
      label: 'Generated Sqoop Options',
      value: table.generatedSqoopOptions,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.generatedSqoopOptions
    }, // Read-only
    {
      label: 'Generated Primary Key Columns',
      value: table.generatedPkColumns,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.generatedPkColumns
    } // Read-only
  ]

  const incrementalImports: EditSetting[] = [
    {
      label: 'Incremental Min Value',
      value: table.incrMinvalue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.incrMinvalue
    }, // Read-only
    {
      label: 'Incremental Max Value',
      value: table.incrMaxvalue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.incrMaxvalue
    }, // Read-only
    {
      label: 'Pending Min Value',
      value: table.incrMinvaluePending,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.incrMinvaluePending
    }, // Read-only
    {
      label: 'Pending Max Value',
      value: table.incrMaxvaluePending,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.incrMaxvaluePending
    }, // Read-only
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Incremental Mode',
      value: mapDisplayValue('incrMode', table.incrMode),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('incrMode'),
      infoText: infoTexts.table.import.incrMode,
      isConditionsMet: table.importPhaseType === ImportType.Incremental
    }, // Enum list, active if importPhaseType=incr
    {
      label: 'Incremental Column',
      value: table.incrColumn,
      type: SettingType.Text,
      infoText: infoTexts.table.import.incrColumn,
      isConditionsMet: table.importPhaseType === ImportType.Incremental
    }, // Free-text, active if importPhaseType=incr
    {
      label: 'Incremental Validation Method',
      value: mapDisplayValue(
        'incrValidationMethod',
        table.incrValidationMethod
      ),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('incrValidationMethod'),
      infoText: infoTexts.table.import.incrValidationMethod,
      isConditionsMet: table.importPhaseType === ImportType.Incremental
    } // Enum list, active if importPhaseType=incr
  ]

  const etlOptions: EditSetting[] = [
    {
      label: 'Create Foreign Keys',
      value: table.createForeignKeys,
      type: SettingType.BooleanOrDefaultFromConnection,
      infoText: infoTexts.table.import.createForeignKeys
    }, // Boolean (1, 0) or Default from Connection (-1)
    {
      label: 'Primary Key Override',
      value: table.pkColumnOverride,
      type: SettingType.Text,
      infoText: infoTexts.table.import.pkColumnOverride
    }, // Comma-separated list with columns from "columns":{}
    {
      label: 'Primary Key Override (Merge only)',
      value: table.pkColumnOverrideMergeonly,
      type: SettingType.Text,
      infoText: infoTexts.table.import.pkColumnOverrideMergeonly
    }, // Comma-separated list with columns from "columns":{}
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Invalidate Impala',
      value: table.invalidateImpala,
      type: SettingType.BooleanOrDefaultFromConfig,
      infoText: infoTexts.table.import.invalidateImpala
    }, // Boolean, (1, 0) or Default from Config (-1)
    {
      label: 'Soft Delete During Merge',
      value: table.softDeleteDuringMerge,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.softDeleteDuringMerge,
      isConditionsMet:
        table.etlPhaseType === EtlType.Merge ||
        table.etlPhaseType === EtlType.MergeHistoryAudit
    }, // Boolean, true or false, active only if etlPhaseType=merge or etlPhaseType=merge_history_audit
    {
      label: 'Merge Compaction Method',
      value: mapDisplayValue(
        'mergeCompactionMethod',
        table.mergeCompactionMethod
      ),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('mergeCompactionMethod'),
      infoText: infoTexts.table.import.mergeCompactionMethod
    }, // Enum mapping for 'Merge Compaction Method'
    {
      label: 'Datalake Source',
      value: table.datalakeSource,
      type: SettingType.Text,
      infoText: infoTexts.table.import.datalakeSource
    } // Free-text setting
  ]

  const performance: EditSetting[] = [
    {
      label: 'Mappers',
      value: table.mappers,
      type: SettingType.IntegerFromOneOrAuto,
      infoText: infoTexts.table.import.mappers
    }, // Integer, -1 = Auto
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Hive Split Count',
      value: table.splitCount,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.table.import.splitCount,
      isConditionsMet: table.etlEngine === EtlEngine.Hive
    }, // Integer, active if etlEngine=hive
    {
      label: 'Hive Tez Container size (MB)',
      value: table.mergeHeap,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.table.import.mergeHeap
    }, // Integer, value is MB
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Spark Executor Memory',
      value: table.sparkExecutorMemory,
      type: SettingType.Text,
      infoText: infoTexts.table.import.sparkExecutorMemory,
      isConditionsMet:
        table.etlEngine === EtlEngine.Spark ||
        table.importTool === ImportTool.Spark
    }, // Free-text, active if etlEngine or importTool=spark
    {
      label: 'Spark Executors',
      value: table.sparkExecutors,
      type: SettingType.IntegerFromOneOrDefaultFromConfig,
      infoText: infoTexts.table.import.sparkExecutors,
      isConditionsMet:
        table.etlEngine === EtlEngine.Spark ||
        table.importTool === ImportTool.Spark
    } // Integer, active if etlEngine or importTool=spark
  ]

  const validation: EditSetting[] = [
    {
      label: 'Validate Import',
      value: table.validateImport,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.validateImport
    }, // Boolean, true or false
    {
      label: 'Validation Method',
      value: mapDisplayValue('validationMethod', table.validationMethod),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('validationMethod'),
      infoText: infoTexts.table.import.validationMethod
    }, // Enum mapping for 'Validation Method'
    {
      label: 'Validate Source',
      value: mapDisplayValue('validateSource', table.validateSource),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('validateSource'),
      infoText: infoTexts.table.import.validateSource
    }, // Enum mapping for 'Validate Source'
    {
      label: 'Allowed Validation Difference',
      value: table.validateDiffAllowed,
      type: SettingType.IntegerFromZeroOrAuto,
      infoText: infoTexts.table.import.validateDiffAllowed
    }, // Integer
    {
      label: 'Custom Query Source SQL',
      value: table.validationCustomQuerySourceSQL,
      type: SettingType.Text,
      infoText: infoTexts.table.import.validationCustomQuerySourceSQL,
      isConditionsMet: table.validationMethod === ValidationMethod.CustomQuery
    }, // free-text, active if validationMethod=customQuery
    {
      label: 'Custom Query Hive SQL',
      value: table.validationCustomQueryHiveSQL,
      type: SettingType.Text,
      infoText: infoTexts.table.import.validationCustomQueryHiveSQL,
      isConditionsMet: table.validationMethod === ValidationMethod.CustomQuery
    }, // free-text, active if validationMethod=customQuery
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Source Row Count',
      value: table.sourceRowcount,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.sourceRowcount
    }, // Read-only setting
    {
      label: 'Source Row Count Incremental',
      value: table.sourceRowcountIncr,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.sourceRowcountIncr
    }, // Read-only setting
    {
      label: 'Target Row Count',
      value: table.targetRowcount,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.targetRowcount
    }, // Read-only setting
    // {
    //   label: 'Validate Import Table',
    //   value: true,
    //   type: SettingType.Boolean,
    //   isHidden: true
    // }, // Always true and always hidden, should not be displayed/visible in UI
    {
      label: 'Custom Query Source Value',
      value: table.validationCustomQuerySourceValue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.validationCustomQuerySourceValue,
      isConditionsMet: table.validationMethod === ValidationMethod.CustomQuery
    }, // Read-only setting
    {
      label: 'Custom Query Hive Value',
      value: table.validationCustomQueryHiveValue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.validationCustomQueryHiveValue,
      isConditionsMet: table.validationMethod === ValidationMethod.CustomQuery
    } // Read-only setting
  ]

  const schedule: EditSetting[] = [
    {
      label: 'Airflow Priority',
      value: table.airflowPriority,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.table.import.airflowPriority
    }, // Integer (should not be string in API)
    {
      label: 'Include in Airflow',
      value: table.includeInAirflow,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.includeInAirflow
    }, // Boolean, true or false
    {
      label: 'Operator Notes',
      value: table.operatorNotes,
      type: SettingType.Text,
      infoText: infoTexts.table.import.operatorNotes
    } // Free-text setting
  ]

  const siteToSiteCopy: EditSetting[] = [
    {
      label: 'Copy Finished',
      value: table.copyFinished,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.copyFinished
    }, // Read-only, timestamp
    {
      label: 'Copy Slave',
      value: table.copySlave,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.copySlave
    } // Read-only, Boolean
  ]

  const importCards = {
    mainSettings,
    importOptions,
    incrementalImports,
    etlOptions,
    performance,
    validation,
    schedule,
    siteToSiteCopy
  }

  return importCards
}

export function importColumnRowDataEdit(row: Columns, table: UITable) {
  const rowData: EditSetting[] = [
    {
      label: 'Column Name',
      value: row.columnName,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.columnName
    }, // Read-only, , free-text
    {
      label: 'Column Order',
      value: row.columnOrder,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.columnOrder
    }, // Number for order in columns, preliminary readonly
    {
      label: 'Source Column Name',
      value: row.sourceColumnName,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.sourceColumnName
    }, // Read-only, free-text
    {
      label: 'Column Type',
      value: row.columnType,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.columnType
    }, // Read-only, free-text
    {
      label: 'Source Column Type',
      value: row.sourceColumnType,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.sourceColumnType
    }, // Read-only, free-text
    {
      label: 'Column Name Override',
      value: row.columnNameOverride,
      type: SettingType.Text,
      infoText: infoTexts.table.import.columns.columnNameOverride
    }, // Free-text
    {
      label: 'Column Type Override',
      value: row.columnTypeOverride,
      type: SettingType.Text,
      infoText: infoTexts.table.import.columns.columnTypeOverride
    }, // Free-text
    {
      label: 'Sqoop Column Type',
      value: row.sqoopColumnType,
      type: SettingType.Readonly,
      isConditionsMet: table.importTool === ImportTool.Sqoop,
      infoText: infoTexts.table.import.columns.sqoopColumnType
    }, // Read-only, free-text, only active if importTool=sqoop
    {
      label: 'Sqoop Column Type Override',
      value: row.sqoopColumnTypeOverride,
      type: SettingType.Text,
      isConditionsMet: table.importTool === ImportTool.Sqoop,
      infoText: infoTexts.table.import.columns.sqoopColumnTypeOverride
    }, // Free-text, only active if importTool=sqoop
    {
      label: 'Force String',
      value: row.forceString,
      type: SettingType.BooleanOrDefaultFromConfig,
      infoText: infoTexts.table.import.columns.forceString
    }, // Boolean or Auto (-1)
    {
      label: 'Include In Import',
      value: row.includeInImport,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.columns.includeInImport
    }, // Boolean, true or false
    {
      label: 'Source Primary Key',
      value: row.sourcePrimaryKey,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.sourcePrimaryKey
    }, // Read-only, Boolean
    {
      label: 'Last Update From Source',
      value: row.lastUpdateFromSource,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.lastUpdateFromSource
    }, // Read-only, Timestamp
    {
      label: 'Comment',
      value: row.comment,
      type: SettingType.Text,
      infoText: infoTexts.table.import.columns.comment
    }, // Free-text
    {
      label: 'Operator Notes',
      value: row.operatorNotes,
      type: SettingType.Text,
      infoText: infoTexts.table.import.columns.operatorNotes
    }, // Free-text
    {
      label: 'Anonymization Function',
      value: row.anonymizationFunction,
      type: SettingType.Enum,
      enumOptions: getEnumOptions('anonymizationFunction'),
      infoText: infoTexts.table.import.columns.anonymizationFunction
    } // Enum mapping for 'Anonymization Function'
  ]

  return rowData
}

export function initialCreateImportTableSettings(
  database: string,
  prefilledConnection: string
) {
  const settings: EditSetting[] = [
    {
      label: 'Database',
      value: database,
      type: SettingType.Text,
      infoText: infoTexts.table.import.database
    }, //Free-text, default selected db, potentially copyable?, required
    {
      label: 'Table',
      value: null,
      type: SettingType.Text,
      infoText: infoTexts.table.import.table
    }, // Free-text, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Connection',
      value: prefilledConnection,
      type: SettingType.ConnectionReferenceRequired,
      infoText: infoTexts.table.import.connection
    }, // Reference to /connection
    {
      label: 'Source Schema',
      value: null,
      type: SettingType.Text,
      infoText: infoTexts.table.import.sourceSchema
    }, // Free-text, varchar(256), required
    {
      label: 'Source Table',
      value: '',
      type: SettingType.Text,
      infoText: infoTexts.table.import.sourceTable
    }, // Free-text, varchar(256), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Import Type',
      value: mapDisplayValue('importPhaseType', ImportType.Full),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importPhaseType'),
      infoText: infoTexts.table.import.importPhaseType
    }, // Enum mapping for 'Import Type'
    {
      label: 'ETL Type',
      value: mapDisplayValue('etlPhaseType', EtlType.TruncateAndInsert),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlPhaseType'),
      infoText: infoTexts.table.import.etlPhaseType
    }, // Enum mapping for 'ETL Type'
    {
      label: 'Import Tool',
      value: mapDisplayValue('importTool', ImportTool.Spark),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importTool'),
      infoText: infoTexts.table.import.importTool
    }, // Enum mapping for 'Import Tool'
    {
      label: 'ETL Engine',
      value: mapDisplayValue('etlEngine', EtlEngine.Spark),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlEngine'),
      infoText: infoTexts.table.import.etlEngine
    } // Enum mapping for 'ETL Engine'
  ]
  return settings
}

// Export

export function exportCnTablesEditSettings(row: UIExportCnTables) {
  const rowData: EditSetting[] = [
    {
      label: 'Database',
      value: row.database,
      type: SettingType.Text,
      infoText: infoTexts.table.export.database
    }, //Free-text, varchar(256), required
    {
      label: 'Table',
      value: row.table,
      type: SettingType.Text,
      infoText: infoTexts.table.export.table
    }, // Free-text, varchar(256), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Export Type',
      value: mapDisplayValue('exportType', row.exportType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportType'),
      infoText: infoTexts.table.export.exportType
    }, // Enum mapping for 'Export Type', required
    {
      label: 'Export Tool',
      value: mapDisplayValue('exportTool', row.exportTool),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportTool'),
      infoText: infoTexts.table.export.exportTool
    } // Enum mapping for 'Export Tool', required
  ]

  return rowData
}

export function exportCardRenderSettings(table: UIExportTable) {
  const mainSettings: EditSetting[] = [
    {
      label: 'Connection',
      value: table.connection,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.connection
    }, // Read-only, required
    {
      label: 'Target Table',
      value: table.targetTable,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.targetTable
    }, // Read-only, required
    {
      label: 'Target Schemna',
      value: table.targetSchema,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.targetSchema
    }, // Read-only, required

    {
      label: 'Database',
      value: table.database,
      type: SettingType.Text,
      infoText: infoTexts.table.export.database
    }, // Free-text, varchar(256), required
    {
      label: 'Table',
      value: table.table,
      type: SettingType.Text,
      infoText: infoTexts.table.export.table
    }, // Free-text, varchar(256), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Export Type',
      value: mapDisplayValue('exportType', table.exportType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportType'),
      infoText: infoTexts.table.export.exportType
    }, // Enum mapping for 'Export Type', required
    {
      label: 'Export Tool',
      value: mapDisplayValue('exportTool', table.exportTool),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportTool'),
      infoText: infoTexts.table.export.exportTool
    }, // Enum mapping for 'Export Tool', required
    {
      label: 'Last Update From Hive',
      value: table.lastUpdateFromHive,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.lastUpdateFromHive
    } // Read-only setting
  ]

  const exportOptions: EditSetting[] = [
    {
      label: 'Sqoop Options',
      value: table.sqoopOptions,
      type: SettingType.Text,
      isConditionsMet: table.exportTool === ExportTool.Sqoop,
      infoText: infoTexts.table.export.sqoopOptions
    }, // Free-text, varchar(1024), active only if exportTool=sqoop
    {
      label: 'Truncate Target',
      value: table.truncateTarget,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.truncateTarget,
      isConditionsMet: table.exportType === ExportType.Full
    }, // Boolean, true or false, active only if exportType=full, required

    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'SQL Where Addition',
      value: table.sqlWhereAddition,
      type: SettingType.Text,
      infoText: infoTexts.table.export.sqlWhereAddition
    }, // Free-text, varchar(1024)
    {
      label: 'Uppercase Columns',
      value: table.uppercaseColumns,
      type: SettingType.BooleanNumberOrAuto,
      infoText: infoTexts.table.export.uppercaseColumns
    }, // Read-only (meanwhile) or maybe IntegerFromOneOrAuto, required
    {
      label: 'Create Target Table Sql',
      value: table.createTargetTableSql,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.createTargetTableSql
    }, // Read-only
    {
      label: 'Force Create Temp Table',
      value: table.forceCreateTempTable,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.forceCreateTempTable
    }, // Boolean, true or false, required

    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Last Size',
      value: table.lastSize,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.lastSize
    }, // Read-only
    {
      label: 'Last Rows',
      value: table.lastRows,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.lastRows
    }, // Read-only
    {
      label: 'Last Mappers',
      value: table.lastMappers,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.lastMappers
    }, // Read-only
    {
      label: 'Last Execution',
      value: table.lastExecution,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.lastExecution
    } // Read-only
  ]

  const incrementalExports: EditSetting[] = [
    {
      label: 'Incremental Min Value',
      value: table.incrMinvalue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.incrMinvalue
    }, // Read-only
    {
      label: 'Incremental Max Value',
      value: table.incrMaxvalue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.incrMaxvalue
    }, // Read-only
    {
      label: 'Pending Min Value',
      value: table.incrMinvaluePending,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.incrMinvaluePending
    }, // Read-only
    {
      label: 'Pending Max Value',
      value: table.incrMaxvaluePending,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.incrMaxvaluePending
    }, // Read-only
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space

    {
      label: 'Incremental Column',
      value: table.incrColumn,
      type: SettingType.Text,
      infoText: infoTexts.table.export.incrColumn,
      isConditionsMet: table.exportType === ExportType.Incremental
    }, // Free-text, varchar(256), active if exportType=incr
    {
      label: 'Incremental Validation Method',
      value: mapDisplayValue(
        'exportIncrValidationMethod',
        table.incrValidationMethod as string
      ),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportIncrValidationMethod'),
      infoText: infoTexts.table.export.incrValidationMethod,
      isConditionsMet: table.exportType === ExportType.Incremental
    } // Enum list, active if exportType=incr
  ]

  const performance: EditSetting[] = [
    {
      label: 'Mappers',
      value: table.mappers,
      type: SettingType.IntegerFromOneOrAuto,
      infoText: infoTexts.table.export.mappers
    }, // Integer, tinyint(4) -1 = Auto, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Hive Tez Container size (MB)',
      value: table.javaHeap,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.table.export.javaHeap
    } // Integer, bigint(20), value is MB
  ]

  const validation: EditSetting[] = [
    {
      label: 'Validate Export',
      value: table.validateExport,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.validateExport
    }, // Boolean, true or false, required
    {
      label: 'Validation Method',
      value: mapDisplayValue(
        'exportValidationMethod',
        table.validationMethod as string
      ),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportValidationMethod'),
      infoText: infoTexts.table.export.validationMethod
    }, // Enum mapping for 'Validation Method', required
    {
      label: 'Custom Query Target SQL',
      value: table.validationCustomQueryTargetSQL,
      type: SettingType.Text,
      infoText: infoTexts.table.export.validationCustomQueryTargetSQL,
      isConditionsMet:
        table.validationMethod === ExportValidationMethod.CustomQuery
    }, // Free-text, 64k, active if validationMethod=customQuery
    {
      label: 'Custom Query Hive SQL',
      value: table.validationCustomQueryHiveSQL,
      type: SettingType.Text,
      infoText: infoTexts.table.export.validationCustomQueryHiveSQL,
      isConditionsMet:
        table.validationMethod === ExportValidationMethod.CustomQuery
    }, // Free-text, 64k, active if validationMethod=customQuery
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Table Row Count',
      value: table.tableRowcount,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.tableRowcount
    }, // Read-only
    {
      label: 'Target Row Count',
      value: table.targetRowcount,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.targetRowcount
    }, // Read-only

    {
      label: 'Custom Query Target Value',
      value: table.validationCustomQueryTargetValue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.validationCustomQueryTargetValue,
      isConditionsMet:
        table.validationMethod === ExportValidationMethod.CustomQuery
    }, // Read-only
    {
      label: 'Custom Query Hive Value',
      value: table.validationCustomQueryHiveValue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.validationCustomQueryHiveValue,
      isConditionsMet:
        table.validationMethod === ExportValidationMethod.CustomQuery
    } // Read-only
  ]

  const schedule: EditSetting[] = [
    {
      label: 'Airflow Priority',
      value: table.airflowPriority,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.table.export.airflowPriority
    }, // Integer, tinyint(4) (should not be string in API)
    {
      label: 'Include in Airflow',
      value: table.includeInAirflow,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.includeInAirflow
    }, // Boolean, true or false, required
    {
      label: 'Operator Notes',
      value: table.operatorNotes,
      type: SettingType.Text,
      infoText: infoTexts.table.export.operatorNotes
    } // Free-text, 64k
  ]

  const exportCards = {
    mainSettings,
    exportOptions,
    incrementalExports,
    performance,
    validation,
    schedule
  }

  return exportCards
}

export function exportColumnRowDataEdit(row: ExportColumns) {
  const rowData: EditSetting[] = [
    {
      label: 'Column Name',
      value: row.columnName,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.columns.columnName
    }, // Read-only, required
    {
      label: 'Column Order',
      value: row.columnOrder,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.columns.columnOrder
    }, // Number for order in columns, preliminary readonly
    {
      label: 'Target Column Name',
      value: row.targetColumnName,
      type: SettingType.Text,
      infoText: infoTexts.table.export.columns.targetColumnName
    }, // Free-text, varchar(256)
    {
      label: 'Column Type',
      value: row.columnType,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.columns.columnType
    }, // Read-only
    {
      label: 'Target Column Type',
      value: row.targetColumnType,
      type: SettingType.Text,
      infoText: infoTexts.table.export.columns.targetColumnType
    }, // Free-text, varchar(256)
    {
      label: 'Last Update From Hive',
      value: row.lastUpdateFromHive,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.columns.lastUpdateFromHive
    }, // Read-only, Timestamp, required
    {
      label: 'Include In Export',
      value: row.includeInExport,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.columns.includeInExport
    }, // Boolean, true or false boolean, required
    {
      label: 'Comment',
      value: row.comment,
      type: SettingType.Text,
      infoText: infoTexts.table.export.columns.comment
    }, // Free-text, 64k
    {
      label: 'Operator Notes',
      value: row.operatorNotes,
      type: SettingType.Text,
      infoText: infoTexts.table.export.columns.operatorNotes
    } // Free-text, 64k
  ]

  return rowData
}

export function initialCreateExportTableSettings(connection: string) {
  const settings: EditSetting[] = [
    {
      label: 'Connection',
      value: connection,
      type: SettingType.Text,
      infoText: infoTexts.table.import.database
    }, //Free-text, default selected db, potentially copyable?, required
    {
      label: 'Table',
      value: null,
      type: SettingType.Text,
      infoText: infoTexts.table.import.table
    }, // Free-text, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Source Schema',
      value: null,
      type: SettingType.Text,
      infoText: infoTexts.table.import.sourceSchema
    }, // Free-text, varchar(256), required
    {
      label: 'Source Table',
      value: '',
      type: SettingType.Text,
      infoText: infoTexts.table.import.sourceTable
    }, // Free-text, varchar(256), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Import Type',
      value: mapDisplayValue('importPhaseType', ImportType.Full),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importPhaseType'),
      infoText: infoTexts.table.import.importPhaseType
    }, // Enum mapping for 'Import Type'
    {
      label: 'ETL Type',
      value: mapDisplayValue('etlPhaseType', EtlType.TruncateAndInsert),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlPhaseType'),
      infoText: infoTexts.table.import.etlPhaseType
    }, // Enum mapping for 'ETL Type'
    {
      label: 'Import Tool',
      value: mapDisplayValue('importTool', ImportTool.Spark),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importTool'),
      infoText: infoTexts.table.import.importTool
    }, // Enum mapping for 'Import Tool'
    {
      label: 'ETL Engine',
      value: mapDisplayValue('etlEngine', EtlEngine.Spark),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlEngine'),
      infoText: infoTexts.table.import.etlEngine
    } // Enum mapping for 'ETL Engine'
  ]
  return settings
}
