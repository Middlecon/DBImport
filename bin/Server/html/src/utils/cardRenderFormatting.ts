import {
  AirflowDAGTaskPlacement,
  AirflowDAGTaskType,
  EtlEngine,
  EtlType,
  ExportTool,
  ExportType,
  ExportValidationMethod,
  ImportTool,
  ImportType,
  SettingType,
  ValidationMethod
} from './enums'
import {
  AirflowTask,
  BulkField,
  Columns,
  ConfigGlobal,
  Connection,
  CustomAirflowDAG,
  EditSetting,
  ExportAirflowDAG,
  ExportColumns,
  ImportAirflowDAG,
  JDBCdrivers,
  UiBulkAirflowDAG,
  UiDbTable,
  UIExportCnTables,
  UIExportTable,
  UITable
} from './interfaces'
import infoTexts from '../infoTexts.json'
import { getEnumOptions, mapDisplayValue } from './nameMappings'

export function airflowCardRenderSettings(
  airflowType: 'import' | 'export' | 'custom',
  dagData: ImportAirflowDAG | ExportAirflowDAG | CustomAirflowDAG
) {
  const baseAirflowDagSettingsPart1: EditSetting[] = [
    {
      label: 'DAG Name',
      value: dagData.name,
      type: SettingType.Readonly,
      infoText: infoTexts.airflow[airflowType].name
    } // Readonly, varchar(64), have to be unique across import, export and custom, required
  ]
  const baseAirflowDagSettingsPart2: EditSetting[] = [
    {
      label: 'Auto Regenerate DAG',
      value: dagData.autoRegenerateDag,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].autoRegenerateDag
    }, // Boolean, if not set pre-set default value: 1, 1 = The DAG will be auto regenerated by manage command, required
    {
      label: 'Schedule Interval',
      value: dagData.scheduleInterval,
      type: SettingType.Text,
      maxChar: 128,
      infoText: infoTexts.airflow[airflowType].scheduleInterval
    }, // Free-text, Time to execute DAG, varchar(128), required?
    {
      label: 'Timezone',
      value: dagData.timezone,
      type: SettingType.TimeZone,
      infoText: infoTexts.airflow[airflowType].timezone
    }, // Timezone,, varchar(64), used for schedule_interval column. Use full text timezone, example Europe/Stockholm
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Sla Warning Time',
      value: dagData.slaWarningTime,
      type: SettingType.Time,
      infoText: infoTexts.airflow[airflowType].slaWarningTime
    }, // Time, Maximum time this DAG should run before Airflow triggers a SLA miss
    {
      label: 'Retries',
      value: dagData.retries,
      type: SettingType.IntegerFromZero,
      maxInt: 127,
      infoText: infoTexts.airflow[airflowType].retries,
      isRequired: true
    } // Integer, tinyint(4), default value: 5 for import & export and 0 for custom, How many retries should be Task do in Airflow before it failes,  required
  ]
  const baseAirflowDagSettingsPart3: EditSetting[] = [
    {
      label: 'Retry Exponential Backoff',
      value: dagData.retryExponentialBackoff
        ? dagData.retryExponentialBackoff
        : false,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].retryExponentialBackoff
    }, // Boolean, if not set pre-set default value: false, true=Use the retry_exponential_backoff Airflow function that will cause the retry between failed tasks to be longer and longer each time instead of a fixed time, false=Run with a fixed time of 5 min between the task retries, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Concurrency',
      value: dagData.concurrency,
      type: SettingType.IntegerFromOneOrNull,
      maxInt: 127,
      infoText: infoTexts.airflow[airflowType].concurrency
    } // Integer, tinyint(4), Set the max Integer of concurrent tasks in the DAG while executing. Overrides the default value specified in Airflow configuration
  ]
  const baseAirflowDagSettingsPart4: EditSetting[] = [
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Email',
      value: dagData.email,
      type: SettingType.Email,
      maxChar: 256,
      infoText: infoTexts.airflow[airflowType].email,
      isConditionsMet:
        dagData.emailOnRetries === true || dagData.emailOnFailure === true
    }, // Free-text, varchar(256), Email to send message to in case email_on_retry or email_on_failure is set to True
    {
      label: 'Email on Failure',
      value: dagData.emailOnFailure ? dagData.emailOnFailure : false,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].emailOnFailure
    }, // Boolean, if not set pre-set default value: false, Send Email on failures, required
    {
      label: 'Email on Retries',
      value: dagData.emailOnRetries ? dagData.emailOnRetries : false,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].emailOnRetries
    }, // Boolean, if not set pre-set default value: false, Send Email on retries, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Sudo User',
      value: dagData.sudoUser,
      type: SettingType.Text,
      maxChar: 64,
      infoText: infoTexts.airflow[airflowType].sudoUser
    }, // Free-text, varchar(64), All tasks in DAG will use this user for sudo instead of default
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Tags',
      value: dagData.tags,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.airflow[airflowType].tags
    }, // Free-text, varchar(256), Comma seperated list of Airflow tags that will be set on the DAG
    {
      label: 'Airflow Notes',
      value: dagData.airflowNotes,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.airflow[airflowType].airflowNotes
    }, // Free-text (64k)
    {
      label: 'Operator notes',
      value: dagData.operatorNotes,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.airflow[airflowType].operatorNotes
    }, // Free-text (64k)
    {
      label: 'Application Notes',
      value: dagData.applicationNotes,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.airflow[airflowType].applicationNotes
    } // Free-text (64k)
  ]

  const airflowImportDagSettingsPart1: EditSetting[] =
    'filterTable' in dagData
      ? [
          {
            label: 'Filter Table',
            value: dagData.filterTable, // column filter_hive in db
            type: SettingType.Textarea,
            maxChar: 64000,
            infoText: infoTexts.airflow.import.filterTable
          } // Free-text, varchar(16384), Filter string for database and table. ; separated. Wildcards (*) allowed. Example HIVE_DB.HIVE_TABLE; HIVE_DB.HIVE_TABLE
        ]
      : []
  const airflowImportDagSettingsPart2: EditSetting[] =
    'filterTable' in dagData
      ? [
          {
            label: 'Retries Import Stage',
            value: dagData.retriesStage1,
            type: SettingType.IntegerFromOneOrNull,
            maxInt: 127,
            infoText: infoTexts.airflow.import.retriesStage1
          }, // Integer, tinyint(4), Specific retries Integer for Import Phase
          {
            label: 'Retries ETL Stage',
            value: dagData.retriesStage2,
            type: SettingType.IntegerFromOneOrNull,
            maxInt: 127,
            infoText: infoTexts.airflow.import.retriesStage2
          } // Integer, tinyint(4), Specific retries Integer for Import Phase
        ]
      : []
  const airflowImportDagSettingsPart3: EditSetting[] =
    'filterTable' in dagData
      ? [
          {
            label: 'Pool Import Stage',
            value: dagData.poolStage1,
            type: SettingType.Text,
            maxChar: 256,
            infoText: infoTexts.airflow.import.poolStage1
          }, // Free-text, varchar(256), Airflow pool used for stage1 tasks. NULL for the default Hostname pool
          {
            label: 'Pool ETL Stage',
            value: dagData.poolStage2,
            type: SettingType.Text,
            maxChar: 256,
            infoText: infoTexts.airflow.import.poolStage2
          }, // Free-text, varchar(256), Airflow pool used for stage2 tasks. NULL for the default DAG pool
          {
            label: 'Finish all Import stages first',
            value: dagData.finishAllStage1First,
            type: SettingType.Boolean,
            infoText: infoTexts.airflow.import.finishAllStage1First
          }, // Boolean, if not set pre-set default value: false, true=All Import phase jobs will be completed first, and when all is successfull, the ETL phase start, required
          {
            label: 'Run Only Metadata Import',
            value: dagData.metadataImport,
            type: SettingType.Boolean,
            infoText: infoTexts.airflow.import.metadataImport
          }, // Boolean, if not set pre-set default value: false, required
          {
            label: 'Run Import and ETL separate',
            value: dagData.runImportAndEtlSeparate,
            type: SettingType.Boolean,
            infoText: infoTexts.airflow.import.runImportAndEtlSeparate
          } // Boolean, if not set pre-set default value: true, required
        ]
      : []

  const airflowExportDagSettings: EditSetting[] =
    'filterConnection' in dagData
      ? [
          {
            label: 'Filter Connection',
            value: dagData.filterConnection, // column filter_hive in db
            type: SettingType.Text,
            maxChar: 256,
            infoText: infoTexts.airflow.export.filterConnection,
            isRequired: true
          }, // Free-text, varchar(256), Filter string for DBALIAS in export_tables, required
          {
            label: 'Filter Target Schema',
            value: dagData.filterTargetSchema,
            type: SettingType.Text,
            maxChar: 256,
            infoText: infoTexts.airflow.export.filterTargetSchema
          }, // Free-text, varchar(256), Filter string for TARGET_SCHEMA  in export_tables
          {
            label: 'Filter Target Table',
            value: dagData.filterTargetTable,
            type: SettingType.Text,
            maxChar: 256,
            infoText: infoTexts.airflow.export.filterTargetTable
          } // Free-text, varchar(256), Filter string for TARGET_TABLE  in export_tables
        ]
      : []

  const airflowCustomDagSettings: EditSetting[] = [
    ...baseAirflowDagSettingsPart1,
    ...baseAirflowDagSettingsPart2,
    ...baseAirflowDagSettingsPart3,
    ...baseAirflowDagSettingsPart4
  ]

  let combinedAirflowDagSettings

  switch (airflowType) {
    case 'import':
      return (combinedAirflowDagSettings = [
        ...baseAirflowDagSettingsPart1,
        ...airflowImportDagSettingsPart1,
        ...baseAirflowDagSettingsPart2,
        ...airflowImportDagSettingsPart2,
        ...baseAirflowDagSettingsPart3,
        ...airflowImportDagSettingsPart3,
        ...baseAirflowDagSettingsPart4
      ])
    case 'export':
      return (combinedAirflowDagSettings = [
        ...baseAirflowDagSettingsPart1,
        ...airflowExportDagSettings,
        ...baseAirflowDagSettingsPart2,
        ...baseAirflowDagSettingsPart3,
        ...baseAirflowDagSettingsPart4
      ])
    case 'custom':
      return (combinedAirflowDagSettings = airflowCustomDagSettings)
  }

  return combinedAirflowDagSettings
}

export function initialCreateAirflowSettings(
  airflowType: 'import' | 'export' | 'custom'
) {
  const baseAirflowDagSettingsPart1: EditSetting[] = [
    {
      label: 'DAG Name',
      value: null,
      type: SettingType.Text,
      maxChar: 64,
      infoText: infoTexts.airflow[airflowType].name,
      isRequired: true
    } //Free-text, varchar(64), have to be unique across import, export and custom, required
  ]
  const baseAirflowDagSettingsPart2: EditSetting[] = [
    {
      label: 'Schedule Interval',
      value: null,
      type: SettingType.Text,
      maxChar: 128,
      infoText: infoTexts.airflow[airflowType].scheduleInterval
    }, // Free-text, Time to execute DAG, varchar(128), required
    {
      label: 'Auto Regenerate DAG',
      value: true,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].autoRegenerateDag
    } // Boolean, if not set pre-set default value: true, true = The DAG will be auto regenerated by manage command, required
  ]

  const airflowImportDagSettings: EditSetting[] = [
    {
      label: 'Filter Table',
      value: null,
      type: SettingType.Textarea,
      maxChar: 16384,
      infoText: infoTexts.airflow.import.filterTable
    } // Free-text, varchar(16384), Filter string for database and table. ; separated. Wildcards (*) allowed. Example HIVE_DB.HIVE_TABLE; HIVE_DB.HIVE_TABLE
  ]

  const airflowExportDagSettings: EditSetting[] = [
    {
      label: 'Filter Connection',
      value: null, // column filter_hive in db
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.airflow.export.filterConnection
    }, // Free-text, varchar(256), Filter string for DBALIAS in export_tables
    {
      label: 'Filter Target Schema',
      value: null,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.airflow.export.filterTargetSchema
    }, // Free-text, varchar(256), Filter string for TARGET_SCHEMA  in export_tables
    {
      label: 'Filter Target Table',
      value: null,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.airflow.export.filterTargetTable
    } // Free-text, varchar(256), Filter string for TARGET_TABLE  in export_tables
  ]

  const airflowCustomDagSettings: EditSetting[] = [
    ...baseAirflowDagSettingsPart1,
    ...baseAirflowDagSettingsPart2
  ]

  let combinedAirflowDagSettings

  switch (airflowType) {
    case 'import':
      return (combinedAirflowDagSettings = [
        ...baseAirflowDagSettingsPart1,
        ...airflowImportDagSettings,
        ...baseAirflowDagSettingsPart2
      ])
    case 'export':
      return (combinedAirflowDagSettings = [
        ...baseAirflowDagSettingsPart1,
        ...airflowExportDagSettings,
        ...baseAirflowDagSettingsPart2
      ])
    case 'custom':
      return (combinedAirflowDagSettings = airflowCustomDagSettings)
  }

  return combinedAirflowDagSettings
}

export function airflowTaskRowDataEdit(row: AirflowTask) {
  const rowData: EditSetting[] = [
    {
      label: 'Task Name',
      value: row.name,
      type: SettingType.Readonly,
      infoText: infoTexts.airflow.tasks.name,
      isHidden: true
    }, // Hidden Readonly, have to be unique across import, export and custom, varchar(64), required
    {
      label: 'Type',
      value: mapDisplayValue('type', row.type),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('type'),
      infoText: infoTexts.airflow.tasks.type
    }, // Enum, 'shell script','Hive SQL','Hive SQL Script','JDBC SQL','Trigger DAG','DAG Sensor','SQL Sensor','DBImport command', required (default value: 'Hive SQL Script')

    {
      label: 'Placement',
      value: mapDisplayValue('placement', row.placement),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('placement'),
      infoText: infoTexts.airflow.tasks.placement
    }, // Enum, 'before main','after main','in main', required (default value: 'after main')

    {
      label: 'Connection',
      value: row.connection,
      type: SettingType.DataReference,
      isConditionsMet: row.type === AirflowDAGTaskType.JDBCSQL,
      infoText: infoTexts.airflow.tasks.connection
    }, // Free-text, only active if "JDBC SQL" is selected in taskType, varchar(256)
    {
      label: 'Airflow Pool',
      value: row.airflowPool,
      type: SettingType.Readonly,
      infoText: infoTexts.airflow.tasks.airflowPool
    }, // Readonly, varchar(64)
    {
      label: 'Airflow Priority',
      value: row.airflowPriority,
      type: SettingType.Text,
      maxChar: 64,
      infoText: infoTexts.airflow.tasks.airflowPriority
    }, // Free-text, varchar(64)
    {
      label: 'Include in Airflow',
      value: row.includeInAirflow ? row.includeInAirflow : true,
      type: SettingType.Boolean,
      infoText: infoTexts.airflow.tasks.includeInAirflow
    }, // Boolean true or false, required (default value: true)
    {
      label: 'Task Dependency Downstream',
      value: row.taskDependencyDownstream,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.airflow.tasks.taskDependencyDownstream
    }, // Free-text, Defines the downstream dependency for the Task. Comma separated list, varchar(256)
    {
      label: 'Task Dependency Upstream',
      value: row.taskDependencyUpstream,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.airflow.tasks.taskDependencyUpstream
    }, // Free-text, Defines the upstream dependency for the Task. Comma separated list, varchar(256)
    {
      label: 'Task Config',
      value: row.taskConfig,
      type: SettingType.Textarea,
      maxChar: 512,
      infoText: infoTexts.airflow.tasks.taskConfig
    }, // Free-text, The configuration for the Task. Depends on what Task type it is,, varchar(512)
    {
      label: 'Sensor Poke Interval',
      value: row.sensorPokeInterval,
      type: SettingType.IntegerFromZeroOrNull,
      isConditionsMet:
        row.type === AirflowDAGTaskType.DAGSensor ||
        row.type === AirflowDAGTaskType.SQLSensor,
      infoText: infoTexts.airflow.tasks.sensorPokeInterval
    }, // Number, Poke interval for sensors in seconds, int(11)
    {
      label: 'Sensor Timeout Minutes',
      value: row.sensorTimeoutMinutes,
      type: SettingType.Readonly,
      infoText: infoTexts.airflow.tasks.sensorTimeoutMinutes
    }, // Readonly, Timeout for sensors in minutes, int(11)
    {
      label: 'Sensor Connection',
      value: row.sensorConnection,
      type: SettingType.Text,
      maxChar: 64,
      isConditionsMet: row.type === AirflowDAGTaskType.SQLSensor,
      infoText: infoTexts.airflow.tasks.sensorConnection
    }, // Free-text, Name of Connection in Airflow, varchar(64)
    {
      label: 'Sensor Soft Fail',
      value: row.sensorSoftFail === 1 ? 1 : 0,
      type: SettingType.BooleanNumber,
      isConditionsMet:
        row.type === AirflowDAGTaskType.DAGSensor ||
        row.type === AirflowDAGTaskType.SQLSensor,
      infoText: infoTexts.airflow.tasks.sensorSoftFail
    }, // Boolean number, Setting this to 1 will add soft_fail=True on sensor (1=true, all else = false), int(11)
    {
      label: 'Sudo User',
      value: row.sudoUser,
      type: SettingType.Text,
      isConditionsMet:
        row.type === AirflowDAGTaskType.DBImportCommand ||
        row.type === AirflowDAGTaskType.JDBCSQL ||
        row.type === AirflowDAGTaskType.HiveSQL ||
        row.type === AirflowDAGTaskType.HiveSQLScript,
      maxChar: 64,
      infoText: infoTexts.airflow.tasks.sudoUser
    } // Free-text, The task will use this user for sudo instead of default, varchar(64)
  ]
  return rowData
}

export const initialCreateAirflowTaskSettings: EditSetting[] = [
  {
    label: 'Task Name',
    value: '',
    type: SettingType.Text,
    maxChar: 64,
    infoText: infoTexts.airflow.tasks.name,
    isRequired: true
  }, // Free-text, varchar(64), have to be unique in the actual DAG and can not be reserved values start or Start or stop or Stop, required
  {
    label: 'Type',
    value: mapDisplayValue('type', AirflowDAGTaskType.HiveSQLScript),
    type: SettingType.Enum,
    enumOptions: getEnumOptions('type'),
    infoText: infoTexts.airflow.tasks.type,
    isRequired: true
  }, // Enum, 'shell script','Hive SQL','Hive SQL Script','JDBC SQL','Trigger DAG','DAG Sensor','SQL Sensor','DBImport command', required (default value: 'Hive SQL Script')

  {
    label: 'Placement',
    value: mapDisplayValue('placement', AirflowDAGTaskPlacement.AfterMain),
    type: SettingType.Enum,
    enumOptions: getEnumOptions('placement'),
    infoText: infoTexts.airflow.tasks.placement,
    isRequired: true
  }, // Enum, 'before main','after main','in main', required (default value: 'after main')

  {
    label: 'Connection',
    value: null,
    type: SettingType.DataReference,
    infoText: infoTexts.airflow.tasks.connection
  }, // Free-text, only active if "JDBC SQL" is selected in taskType, varchar(256)
  // {
  //   label: 'Airflow Pool',
  //   value: null,
  //   type: SettingType.Readonly,
  //   infoText: infoTexts.airflow.tasks.airflowPool
  // }, // Readonly, varchar(64)
  {
    label: 'Airflow Priority',
    value: null,
    type: SettingType.Text,
    maxChar: 64,
    infoText: infoTexts.airflow.tasks.airflowPriority
  }, // Free-text, varchar(64)
  {
    label: 'Include in Airflow',
    value: true,
    type: SettingType.Boolean,
    infoText: infoTexts.airflow.tasks.includeInAirflow,
    isRequired: true
  }, // Boolean true or false, required (default value: true)
  {
    label: 'Task Dependency Downstream',
    value: null,
    type: SettingType.Text,
    maxChar: 256,
    infoText: infoTexts.airflow.tasks.taskDependencyDownstream
  }, // Free-text, Defines the downstream dependency for the Task. Comma separated list, varchar(256)
  {
    label: 'Task Dependency Upstream',
    value: null,
    type: SettingType.Text,
    maxChar: 256,
    infoText: infoTexts.airflow.tasks.taskDependencyUpstream
  }, // Free-text, Defines the upstream dependency for the Task. Comma separated list, varchar(256)
  {
    label: 'Task Config',
    value: null,
    type: SettingType.Textarea,
    maxChar: 512,
    infoText: infoTexts.airflow.tasks.taskConfig
  }, // Free-text, The configuration for the Task. Depends on what Task type it is,, varchar(512)
  {
    label: 'Sensor Poke Interval',
    value: null,
    type: SettingType.IntegerFromZeroOrNull,
    infoText: infoTexts.airflow.tasks.sensorPokeInterval
  }, // Number, Poke interval for sensors in seconds, int(11)
  // {
  //   label: 'Sensor Timeout Minutes',
  //   value: null,
  //   type: SettingType.Readonly,
  //   infoText: infoTexts.airflow.tasks.sensorTimeoutMinutes
  // }, // Readonly, Timeout for sensors in minutes, int(11)
  {
    label: 'Sensor Connection',
    value: null,
    type: SettingType.Text,
    maxChar: 64,
    infoText: infoTexts.airflow.tasks.sensorConnection
  }, // Free-text, Name of Connection in Airflow, varchar(64)
  {
    label: 'Sensor Soft Fail',
    value: null,
    type: SettingType.BooleanNumber,
    infoText: infoTexts.airflow.tasks.sensorSoftFail
  }, // Boolean number, Setting this to 1 will add soft_fail=True on sensor (1=true, all else = false), int(11)
  {
    label: 'Sudo User',
    value: null,
    type: SettingType.Text,
    maxChar: 64,
    infoText: infoTexts.airflow.tasks.sudoUser
  } // Free-text, The task will use this user for sudo instead of default, varchar(64)
]

export function copyAirflowTaskSettings(taskName: string) {
  const settings: EditSetting[] = [
    {
      label: 'Task Name',
      value: taskName,
      type: SettingType.Text,
      maxChar: 64,
      infoText: infoTexts.airflow.tasks.name,
      isRequired: true
    } // Free-text, varchar(64), have to be unique in the actual DAG and can not be reserved values start or Start or stop or Stop, required
  ]
  return settings
}

export function generateDagSettings(dagName: string) {
  const settings: EditSetting[] = [
    {
      label: 'DAG Name',
      value: dagName,
      type: SettingType.Readonly
    } // Readonly
  ]
  return settings
}

// Connection

export function encryptCredentialsSettings(connectionName: string) {
  const settings: EditSetting[] = [
    {
      label: 'Connection',
      value: connectionName,
      type: SettingType.Readonly,
      maxChar: 256
    }, // Readonly, varchar(256)
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Username',
      value: '',
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.connectionEncryptCredentials.username,
      isRequired: true
    }, // Free-text, varchar(256)
    {
      label: 'Password',
      value: '',
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.connectionEncryptCredentials.password,
      isRequired: true
    } // Free-text, varchar(256)
  ]
  return settings
}

export const generateConnectionStringFields: EditSetting[] = [
  {
    label: 'Database type',
    value: null,
    type: SettingType.DataReferenceRequired
    // infoText:
  }, // Database types from JDBC drivers, enum in database, required
  {
    label: 'Version',
    value: 'default',
    type: SettingType.Version
    // infoText:
  }, // Compatible options to selected Database type, 'default' or, only for Database type 'SQL Server': 'default', 'jTDS', set initially to 'default' (varchar(16) in database), required
  {
    label: 'Hostname',
    value: null,
    type: SettingType.Text,
    maxChar: 256
    // infoText:
  }, //  Free-text, varchar(256), required
  {
    label: 'Port',
    value: null,
    type: SettingType.Text,
    maxChar: 8
    // infoText:
  }, // Free-text, varchar(8)
  {
    label: 'Database',
    value: null,
    type: SettingType.Text,
    maxChar: 256
    // infoText:
  } //  Free-text, varchar(256), required
]

export function connectionCardRenderSettings(connection: Connection) {
  const connectionSettings: EditSetting[] = [
    // {
    //   label: 'Name',
    //   value: connection.name,
    //   type: SettingType.Text,
    //   infoText: infoTexts.connection.name
    // }, //Free-text (varchar 256)
    {
      label: 'Connection string',
      value: connection.connectionString,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.connection.connectionString,
      isRequired: true
    }, // Free-text (64k)
    {
      label: 'Private Key Path',
      value: connection.privateKeyPath,
      type: SettingType.Text,
      maxChar: 128,
      infoText: infoTexts.connection.privateKeyPath
    }, // Free-text (varchar 128)
    {
      label: 'Public Key Path',
      value: connection.publicKeyPath,
      type: SettingType.Text,
      maxChar: 128,
      infoText: infoTexts.connection.publicKeyPath
    }, // Free-text (varchar 128)
    {
      label: 'Credentials',
      value: connection.credentials !== null ? connection.credentials : '',
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.connection.credentials
    }, // Free-text (64k)

    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Source',
      value: connection.source,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.connection.source
    }, // Free-text (varchar 256)
    {
      label: 'Force String',
      value: connection.forceString,
      type: SettingType.BooleanOrDefaultFromConfig,
      infoText: infoTexts.connection.forceString
    }, // Boolean, (1, 0) or Default from Config (-1)
    {
      label: 'Max Sessions',
      value: connection.maxSessions,
      type: SettingType.IntegerFromOneOrNull,
      maxInt: 127,
      infoText: infoTexts.connection.maxSessions
    }, // Integer, tinyint(4)
    {
      label: 'Create Foreign Key',
      value: connection.createForeignKey,
      type: SettingType.Boolean,
      infoText: infoTexts.connection.createForeignKey
    }, // Boolean, true or false
    {
      label: 'Create Datalake Import',
      value: connection.createDatalakeImport,
      type: SettingType.Boolean,
      infoText: infoTexts.connection.createDatalakeImport
    }, // Boolean, true or false
    {
      label: 'Time Window Start',
      value: connection.timeWindowStart,
      type: SettingType.Time,
      infoText: infoTexts.connection.timeWindowStart
    }, // Time
    {
      label: 'Time Window Stop',
      value: connection.timeWindowStop,
      type: SettingType.Time,
      infoText: infoTexts.connection.timeWindowStop
    }, // Time
    {
      label: 'Time Window Timezone',
      value: connection.timeWindowTimezone,
      type: SettingType.TimeZone,
      infoText: infoTexts.connection.timeWindowTimezone
    }, // TimeZone
    {
      label: 'Seed File',
      value: connection.seedFile,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.connection.seedFile
    }, // Free-text (varchar 256)

    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Operator notes',
      value: connection.operatorNotes,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.connection.operatorNotes
    }, // Free-text (64k)
    {
      label: 'Contact information',
      value: connection.contactInformation,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.connection.contactInformation
    }, // Free-text (varchar 256)
    {
      label: 'Description',
      value: connection.description,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.connection.description
    }, // Free-text (varchar 256)
    {
      label: 'Owner',
      value: connection.owner,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.connection.owner
    }, // Free-text (varchar 256)
    // {
    //   label: 'Environment',
    //   value: connection.environment,
    //   type: SettingType.Text,
    // maxChar: 256,
    // }, // Free-text (varchar 256), skip this because functionality for it is not yet implemented in the system
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Atlas Discovery',
      value: connection.atlasDiscovery,
      type: SettingType.Boolean,
      infoText: infoTexts.connection.atlasDiscovery
    }, // Boolean, true or false
    {
      label: 'Atlas Include Filter',
      value: connection.atlasIncludeFilter,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.connection.atlasIncludeFilter
    }, // Free-text (varchar 256)
    {
      label: 'Atlas Exclude Filter',
      value: connection.atlasExcludeFilter,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.connection.atlasExcludeFilter
    }, // Free-text (varchar 256)
    {
      label: 'Atlas Last Discovery',
      value: connection.atlasLastDiscovery,
      type: SettingType.Readonly,
      infoText: infoTexts.connection.atlasLastDiscovery
    } // Readonly (varchar 256)
  ]
  return connectionSettings
}

export const initialCreateConnectionSettings: EditSetting[] = [
  {
    label: 'Name',
    value: '',
    type: SettingType.Text,
    maxChar: 256,
    infoText: infoTexts.connection.name
  }, //Free-text (varchar 256)
  {
    label: 'Connection string',
    value: '',
    type: SettingType.Textarea,
    maxChar: 64000,
    infoText: infoTexts.connection.connectionString,
    isRequired: true
  }, // Free-text (64k)
  {
    label: 'Operator notes',
    value: null,
    type: SettingType.Textarea,
    maxChar: 64000,
    infoText: infoTexts.connection.operatorNotes
  }, // Free-text (64k)
  {
    label: 'Contact information',
    value: null,
    type: SettingType.Text,
    maxChar: 256,
    infoText: infoTexts.connection.contactInformation
  }, // Free-text (varchar 256)
  {
    label: 'Description',
    value: null,
    type: SettingType.Text,
    maxChar: 256,
    infoText: infoTexts.connection.description
  }, // Free-text (varchar 256)
  {
    label: 'Owner',
    value: null,
    type: SettingType.Text,
    maxChar: 256,
    infoText: infoTexts.connection.owner
  }, // Free-text (varchar 256)

  {
    label: '',
    value: '',
    type: SettingType.GroupingSpace
  } // Layout space
]

// Import and Export

export function tableNameReadonlySettings(
  label: string,
  databaseName: string,
  tableName: string,
  connectionName?: string | undefined,
  schemaName?: string | undefined
) {
  const settings: EditSetting[] = [
    {
      label: label,
      value: `${databaseName}.${
        schemaName ? `${schemaName}.` : ''
      }${tableName}`,
      type: SettingType.Readonly
    } // Readonly
  ]

  if (connectionName) {
    settings.unshift(
      {
        label: 'Connection',
        value: connectionName,
        type: SettingType.Readonly
      } // Readonly
    )
  }

  return settings
}

export function copyImportTableSettings(
  prefilledDatabase: string,
  prefilledTable: string
) {
  const settings: EditSetting[] = [
    {
      label: 'Database',
      value: prefilledDatabase,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.database,
      isRequired: true
    }, //Free-text, required
    {
      label: 'Table',
      value: prefilledTable,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.table,
      isRequired: true
    } // Free-text, required
  ]
  return settings
}

export function copyExportTableSettings(
  prefilledConnection: string,
  prefilledTargetTable: string,
  prefilledTargetSchema: string
) {
  const settings: EditSetting[] = [
    {
      label: 'Connection',
      value: prefilledConnection,
      type: SettingType.DataReferenceRequired,
      maxChar: 256,
      infoText: infoTexts.table.export.connection,
      isRequired: true
    }, //Connections-dropdown, default selected connection, varchar(256), required
    {
      label: 'Target Table',
      value: prefilledTargetTable,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.targetTable,
      isRequired: true
    }, // Free-text, varchar(256), required
    {
      label: 'Target Schema',
      value: prefilledTargetSchema,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.targetSchema,
      isRequired: true
    } // Free-text, varchar(256), required
  ]
  return settings
}

// Import

export function initEnumDropdownFilters(
  importType: string | null,
  importTool: string | null,
  etlType: string | null,
  etlEngine: string | null
) {
  const filterData: EditSetting[] = [
    {
      label: 'Import Type',
      value: importType,
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importPhaseType')
    },
    {
      label: 'Import Tool',
      value: importTool,
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importTool')
    },
    {
      label: 'ETL Type',
      value: etlType,
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlPhaseType')
    },
    {
      label: 'ETL Engine',
      value: etlEngine,
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlEngine')
    }
  ]

  return filterData
}

export function importDbTablesEditSettings(row: UiDbTable) {
  const rowData: EditSetting[] = [
    {
      label: 'Database',
      value: row.database,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.database
    }, //Free-text, read-only, default selected db, potentially copyable?
    {
      label: 'Table',
      value: row.table,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.table
    }, // Free-text, read-only
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Import Type',
      value: mapDisplayValue('importPhaseType', row.importPhaseType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importPhaseType'),
      infoText: infoTexts.table.import.importPhaseType
    }, // Enum mapping for 'Import Type'
    {
      label: 'Import Tool',
      value: mapDisplayValue('importTool', row.importTool),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importTool'),
      infoText: infoTexts.table.import.importTool
    }, // Enum mapping for 'Import Tool'
    {
      label: 'ETL Type',
      value: mapDisplayValue('etlPhaseType', row.etlPhaseType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlPhaseType'),
      infoText: infoTexts.table.import.etlPhaseType
    }, // Enum mapping for 'ETL Type'
    {
      label: 'ETL Engine',
      value: mapDisplayValue('etlEngine', row.etlEngine),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlEngine'),
      infoText: infoTexts.table.import.etlEngine
    }, // Enum mapping for 'ETL Engine'
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Include in Airflow',
      value: row.includeInAirflow,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.includeInAirflow
    } // Boolean, true or false
  ]
  return rowData
}

export function importCardRenderSettings(table: UITable) {
  // Text types have limitation varchar(256) if no other is specified in comment

  const mainSettings: EditSetting[] = [
    {
      label: 'Database',
      value: table.database,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.database
    }, // Read-only, default selected db, potentially copyable?
    {
      label: 'Table',
      value: table.table,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.table
    }, // Read-only
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Connection',
      value: table.connection,
      type: SettingType.DataReferenceRequired,
      infoText: infoTexts.table.import.connection
    }, // Reference to /connection
    {
      label: 'Source Database Type',
      value: table.columns?.[0]?.sourceDatabaseType ?? '',
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.sourceDatabaseType
    }, // Read-only, free-text, should be displayed, from inside table.columns[]
    {
      label: 'Source Schema',
      value: table.sourceSchema,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.sourceSchema,
      isRequired: true
    }, // Free-text, required
    {
      label: 'Source Table',
      value: table.sourceTable,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.sourceTable,
      isRequired: true
    }, // Free-text
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Import Type',
      value: mapDisplayValue('importPhaseType', table.importPhaseType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importPhaseType'),
      infoText: infoTexts.table.import.importPhaseType
    }, // Enum mapping for 'Import Type'
    {
      label: 'Import Tool',
      value: mapDisplayValue('importTool', table.importTool),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importTool'),
      infoText: infoTexts.table.import.importTool
    }, // Enum mapping for 'Import Tool'
    {
      label: 'ETL Type',
      value: mapDisplayValue('etlPhaseType', table.etlPhaseType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlPhaseType'),
      infoText: infoTexts.table.import.etlPhaseType
    }, // Enum mapping for 'ETL Type'
    {
      label: 'ETL Engine',
      value: mapDisplayValue('etlEngine', table.etlEngine),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlEngine'),
      infoText: infoTexts.table.import.etlEngine
    }, // Enum mapping for 'ETL Engine'
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Last update from source',
      value: table.lastUpdateFromSource,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.lastUpdateFromSource
    }, // Read-only
    {
      label: 'Source Table Type',
      value: table.sourceTableType,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.sourceTableType
    }, // Read-only
    {
      label: 'Comment',
      value: table.comment,
      type: SettingType.Readonly
      // infoText: infoTexts.table.import.comment
    }, // Read-only
    {
      label: 'Import Database',
      value: table.importDatabase,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.importDatabase
    }, // Free-text
    {
      label: 'Import Table',
      value: table.importTable,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.importTable
    }, // Free-text
    {
      label: 'History Database',
      value: table.historyDatabase,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.historyDatabase
    }, // Free-text
    {
      label: 'History Table',
      value: table.historyTable,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.historyTable
    } // Free-text
  ]

  const importOptions: EditSetting[] = [
    {
      label: 'Allow Text Splitter',
      value: table.allowTextSplitter,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.allowTextSplitter
    }, // Boolean, true or false
    {
      label: 'Force String',
      value: table.forceString,
      type: SettingType.BooleanOrDefaultFromConfig,
      infoText: infoTexts.table.import.forceString
    }, //  Boolean, (1, 0) or Default from Config (-1)
    {
      label: 'Split by Column',
      value: table.splitByColumn,
      type: SettingType.Text,
      maxChar: 64,
      infoText: infoTexts.table.import.splitByColumn
    }, // Free-text, varchar(64)
    {
      label: 'Sqoop Options',
      value: table.sqoopOptions,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.table.import.sqoopOptions,
      isConditionsMet: table.importTool === ImportTool.Sqoop
    }, // Free-text, 64k, active only if importTool=sqoop
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'SQL WHERE Addition',
      value: table.sqlWhereAddition,
      type: SettingType.Textarea,
      maxChar: 1024,
      infoText: infoTexts.table.import.sqlWhereAddition
    }, // Free-text, varchar(1024)
    {
      label: 'Custom Max Query',
      value: table.customMaxQuery,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.customMaxQuery,
      isConditionsMet:
        table.importPhaseType === ImportType.Incremental ||
        table.importPhaseType === ImportType.MSSQLChangeTracking ||
        table.importPhaseType === ImportType.OracleFlashback
    }, // Active only if import type is of an incremental type, either Incremental, MSSQLChangeTracking or OracleFlashback
    {
      label: 'Sqoop use Generated SQL',
      value: table.sqoopUseGeneratedSql,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.sqoopUseGeneratedSql,
      isConditionsMet: table.importTool === ImportTool.Sqoop
    }, // Boolean, true or false
    {
      label: 'Scoop Custom Query',
      value: table.sqoopCustomQuery,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.table.import.sqoopCustomQuery,
      isConditionsMet: table.importTool === ImportTool.Sqoop
    }, // Active only if sqoopUseGeneratedSql=false, 64k
    {
      label: 'No Merge Ingestion SQL Addition',
      value: table.nomergeIngestionSqlAddition,
      type: SettingType.Textarea,
      maxChar: 2048,
      infoText: infoTexts.table.import.nomergeIngestionSqlAddition
    }, // Free-text setting (nmore information might come about this one), varchar(2048)
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Last Size',
      value: table.lastSize,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.lastSize
    }, // Read-only
    {
      label: 'Last Rows',
      value: table.lastRows,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.lastRows
    }, // Read-only
    {
      label: 'Last number of SQL Sessions',
      value: table.lastSqlSessions,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.lastSqlSessions
    }, // Read-only
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Generated Hive Column Definition',
      value: table.generatedHiveColumnDefinition,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.generatedHiveColumnDefinition
    }, // Read-only
    {
      label: 'Generated Sqoop Query',
      value: table.generatedSqoopQuery,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.generatedSqoopQuery
    }, // Read-only
    {
      label: 'Generated Sqoop Options',
      value: table.generatedSqoopOptions,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.generatedSqoopOptions
    }, // Read-only
    {
      label: 'Generated Primary Key Columns',
      value: table.generatedPkColumns,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.generatedPkColumns
    } // Read-only
  ]

  const incrementalImports: EditSetting[] = [
    {
      label: 'Incremental Mode',
      value: mapDisplayValue('incrMode', table.incrMode),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('incrMode'),
      infoText: infoTexts.table.import.incrMode,
      isConditionsMet: table.importPhaseType === ImportType.Incremental
    }, // Enum list, active if importPhaseType=incr
    {
      label: 'Incremental Column',
      value: table.incrColumn,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.incrColumn,
      isConditionsMet: table.importPhaseType === ImportType.Incremental
    }, // Free-text, active if importPhaseType=incr
    {
      label: 'Incremental Validation Method',
      value: mapDisplayValue(
        'incrValidationMethod',
        table.incrValidationMethod
      ),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('incrValidationMethod'),
      infoText: infoTexts.table.import.incrValidationMethod,
      isConditionsMet: table.importPhaseType === ImportType.Incremental
    }, // Enum list, active if importPhaseType=incr
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Incremental Min Value',
      value: table.incrMinvalue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.incrMinvalue
    }, // Read-only
    {
      label: 'Incremental Max Value',
      value: table.incrMaxvalue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.incrMaxvalue
    }, // Read-only
    {
      label: 'Pending Min Value',
      value: table.incrMinvaluePending,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.incrMinvaluePending
    }, // Read-only
    {
      label: 'Pending Max Value',
      value: table.incrMaxvaluePending,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.incrMaxvaluePending
    } // Read-only
  ]

  const etlOptions: EditSetting[] = [
    {
      label: 'Create Foreign Keys',
      value: table.createForeignKeys,
      type: SettingType.BooleanOrDefaultFromConnection,
      infoText: infoTexts.table.import.createForeignKeys
    }, // Boolean (1, 0) or Default from Connection (-1)
    {
      label: 'Primary Key Override',
      value: table.pkColumnOverride,
      type: SettingType.Textarea,
      maxChar: 1024,
      infoText: infoTexts.table.import.pkColumnOverride
    }, // Comma-separated list with columns from "columns":{}, varchar(1024)
    {
      label: 'Primary Key Override (Merge only)',
      value: table.pkColumnOverrideMergeonly,
      type: SettingType.Textarea,
      maxChar: 1024,
      infoText: infoTexts.table.import.pkColumnOverrideMergeonly
    }, // Comma-separated list with columns from "columns":{}, varchar(1024)
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Invalidate Impala',
      value: table.invalidateImpala,
      type: SettingType.BooleanOrDefaultFromConfig,
      infoText: infoTexts.table.import.invalidateImpala
    }, // Boolean, (1, 0) or Default from Config (-1)
    {
      label: 'Soft Delete during Merge',
      value: table.softDeleteDuringMerge,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.softDeleteDuringMerge,
      isConditionsMet:
        table.etlPhaseType === EtlType.Merge ||
        table.etlPhaseType === EtlType.MergeHistoryAudit
    }, // Boolean, true or false, active only if etlPhaseType=merge or etlPhaseType=merge_history_audit
    {
      label: 'Merge Compaction Method',
      value: mapDisplayValue(
        'mergeCompactionMethod',
        table.mergeCompactionMethod
      ),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('mergeCompactionMethod'),
      infoText: infoTexts.table.import.mergeCompactionMethod
    }, // Enum mapping for 'Merge Compaction Method'
    {
      label: 'Datalake Source',
      value: table.datalakeSource,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.datalakeSource
    } // Free-text setting
  ]

  const performance: EditSetting[] = [
    {
      label: 'SQL Sessions',
      value: table.sqlSessions,
      type: SettingType.IntegerFromOneOrAuto,
      maxInt: 127,
      infoText: infoTexts.table.import.sqlSessions,
      isRequired: true
    }, // Integer, tinyint(4), -1 = Auto, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Hive Split Count',
      value: table.splitCount,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.table.import.splitCount,
      isConditionsMet: table.etlEngine === EtlEngine.Hive
    }, // Integer, int(11), active if etlEngine=hive
    {
      label: 'Hive Tez Container size (MB)',
      value: table.hiveContainerSize,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.table.import.hiveContainerSize
    }, // Integer, int(11), value is MB
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Spark Executor Memory',
      value: table.sparkExecutorMemory,
      type: SettingType.Text,
      maxChar: 8,
      infoText: infoTexts.table.import.sparkExecutorMemory,
      isConditionsMet:
        table.etlEngine === EtlEngine.Spark ||
        table.importTool === ImportTool.Spark
    }, // Free-text, active if etlEngine or importTool=spark, varchar(8)
    {
      label: 'Spark Executors',
      value: table.sparkExecutors,
      type: SettingType.IntegerFromOneOrDefaultFromConfig,
      infoText: infoTexts.table.import.sparkExecutors,
      isConditionsMet:
        table.etlEngine === EtlEngine.Spark ||
        table.importTool === ImportTool.Spark
    } // Integer, int(11), active if etlEngine or importTool=spark
  ]

  const validation: EditSetting[] = [
    {
      label: 'Validate Import',
      value: table.validateImport,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.validateImport
    }, // Boolean, true or false
    {
      label: 'Validation Method',
      value: mapDisplayValue('validationMethod', table.validationMethod),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('validationMethod'),
      infoText: infoTexts.table.import.validationMethod
    }, // Enum mapping for 'Validation Method'
    {
      label: 'Validate Source',
      value: mapDisplayValue('validateSource', table.validateSource),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('validateSource'),
      infoText: infoTexts.table.import.validateSource
    }, // Enum mapping for 'Validate Source'
    {
      label: 'Allowed Validation Difference',
      value: table.validateDiffAllowed,
      type: SettingType.IntegerFromZeroOrAuto,
      infoText: infoTexts.table.import.validateDiffAllowed
    }, // Integer, bigInt(20)
    {
      label: 'Custom Query Source SQL',
      value: table.validationCustomQuerySourceSQL,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.table.import.validationCustomQuerySourceSQL,
      isConditionsMet: table.validationMethod === ValidationMethod.CustomQuery
    }, // free-text, active if validationMethod=customQuery, 64k
    {
      label: 'Custom Query Hive SQL',
      value: table.validationCustomQueryHiveSQL,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.table.import.validationCustomQueryHiveSQL,
      isConditionsMet: table.validationMethod === ValidationMethod.CustomQuery
    }, // free-text, active if validationMethod=customQuery, 64k
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Source Row Count',
      value: table.sourceRowcount,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.sourceRowcount
    }, // Read-only setting
    {
      label: 'Source Row Count Incremental',
      value: table.sourceRowcountIncr,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.sourceRowcountIncr
    }, // Read-only setting
    {
      label: 'Target Row Count',
      value: table.targetRowcount,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.targetRowcount
    }, // Read-only setting
    // {
    //   label: 'Validate Import Table',
    //   value: true,
    //   type: SettingType.Boolean,
    //   isHidden: true
    // }, // Always true and always hidden, should not be displayed/visible in UI
    {
      label: 'Custom Query Source Value',
      value: table.validationCustomQuerySourceValue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.validationCustomQuerySourceValue,
      isConditionsMet: table.validationMethod === ValidationMethod.CustomQuery
    }, // Read-only setting
    {
      label: 'Custom Query Hive Value',
      value: table.validationCustomQueryHiveValue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.validationCustomQueryHiveValue,
      isConditionsMet: table.validationMethod === ValidationMethod.CustomQuery
    } // Read-only setting
  ]

  const schedule: EditSetting[] = [
    {
      label: 'Airflow Priority',
      value: table.airflowPriority,
      type: SettingType.IntegerFromOneOrNull,
      maxInt: 127,
      infoText: infoTexts.table.import.airflowPriority
    }, // Integer, tinyint(4), (should not be string in API)
    {
      label: 'Include in Airflow',
      value: table.includeInAirflow,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.includeInAirflow
    }, // Boolean, true or false
    {
      label: 'Operator notes',
      value: table.operatorNotes,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.table.import.operatorNotes
    } // Free-text setting, 64k
  ]

  const siteToSiteCopy: EditSetting[] = [
    {
      label: 'Copy Finished',
      value: table.copyFinished,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.copyFinished
    }, // Read-only, timestamp
    {
      label: 'Copy Slave',
      value: table.copySlave,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.copySlave
    } // Read-only, Boolean
  ]

  const importCards = {
    mainSettings,
    importOptions,
    incrementalImports,
    etlOptions,
    performance,
    validation,
    schedule,
    siteToSiteCopy
  }

  return importCards
}

export function importColumnRowDataEdit(row: Columns, table: UITable) {
  const rowData: EditSetting[] = [
    {
      label: 'Column Name',
      value: row.columnName,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.columnName
    }, // Read-only, free-text
    {
      label: 'Column Order',
      value: row.columnOrder,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.columnOrder
    }, // Number for order in columns, preliminary readonly
    {
      label: 'Source Column Name',
      value: row.sourceColumnName,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.sourceColumnName
    }, // Read-only, free-text
    {
      label: 'Column Type',
      value: row.columnType,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.columnType
    }, // Read-only, free-text
    {
      label: 'Source Column Type',
      value: row.sourceColumnType,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.sourceColumnType
    }, // Read-only, free-text
    {
      label: 'Column Name Override',
      value: row.columnNameOverride,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.columns.columnNameOverride
    }, // Free-text
    {
      label: 'Column Type Override',
      value: row.columnTypeOverride,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.columns.columnTypeOverride
    }, // Free-text
    {
      label: 'Sqoop Column Type',
      value: row.sqoopColumnType,
      type: SettingType.Readonly,
      isConditionsMet: table.importTool === ImportTool.Sqoop,
      infoText: infoTexts.table.import.columns.sqoopColumnType
    }, // Read-only, free-text, only active if importTool=sqoop
    {
      label: 'Sqoop Column Type Override',
      value: row.sqoopColumnTypeOverride,
      type: SettingType.Text,
      maxChar: 256,
      isConditionsMet: table.importTool === ImportTool.Sqoop,
      infoText: infoTexts.table.import.columns.sqoopColumnTypeOverride
    }, // Free-text, only active if importTool=sqoop
    {
      label: 'Force String',
      value: row.forceString,
      type: SettingType.BooleanOrDefaultFromConfig,
      infoText: infoTexts.table.import.columns.forceString
    }, // Boolean or Auto (-1)
    {
      label: 'Include in Import',
      value: row.includeInImport,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.columns.includeInImport
    }, // Boolean, true or false
    {
      label: 'Source Primary Key',
      value: row.sourcePrimaryKey,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.sourcePrimaryKey
    }, // Read-only, Boolean
    {
      label: 'Last update from source',
      value: row.lastUpdateFromSource,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.lastUpdateFromSource
    }, // Read-only, Timestamp
    {
      label: 'Comment',
      value: row.comment,
      type: SettingType.Readonly,
      infoText: infoTexts.table.import.columns.comment
    }, // Free-text
    {
      label: 'Operator notes',
      value: row.operatorNotes,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.table.import.columns.operatorNotes
    }, // Free-text, 64k
    {
      label: 'Anonymization Function',
      value: row.anonymizationFunction,
      type: SettingType.Enum,
      enumOptions: getEnumOptions('anonymizationFunction'),
      infoText: infoTexts.table.import.columns.anonymizationFunction
    } // Enum mapping for 'Anonymization Function'
  ]

  return rowData
}

export function initialCreateImportTableSettings(
  prefilledDatabase: string | null,
  prefilledConnection: string | null
) {
  const settings: EditSetting[] = [
    {
      label: 'Database',
      value: prefilledDatabase,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.database,
      isRequired: true
    }, //Free-text, default selected db, potentially copyable?, required
    {
      label: 'Table',
      value: null,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.table,
      isRequired: true
    }, // Free-text, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Connection',
      value: prefilledConnection,
      type: SettingType.DataReferenceRequired,
      infoText: infoTexts.table.import.connection,
      isRequired: true
    }, // Reference to /connection
    {
      label: 'Source Schema',
      value: null,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.sourceSchema,
      isRequired: true
    }, // Free-text, varchar(256), required
    {
      label: 'Source Table',
      value: '',
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.import.sourceTable,
      isRequired: true
    }, // Free-text, varchar(256), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Import Type',
      value: mapDisplayValue('importPhaseType', ImportType.Full),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importPhaseType'),
      infoText: infoTexts.table.import.importPhaseType
    }, // Enum mapping for 'Import Type'
    {
      label: 'Import Tool',
      value: mapDisplayValue('importTool', ImportTool.Spark),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('importTool'),
      infoText: infoTexts.table.import.importTool
    }, // Enum mapping for 'Import Tool'
    {
      label: 'ETL Type',
      value: mapDisplayValue('etlPhaseType', EtlType.TruncateAndInsert),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlPhaseType'),
      infoText: infoTexts.table.import.etlPhaseType
    }, // Enum mapping for 'ETL Type'
    {
      label: 'ETL Engine',
      value: mapDisplayValue('etlEngine', EtlEngine.Spark),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('etlEngine'),
      infoText: infoTexts.table.import.etlEngine
    }, // Enum mapping for 'ETL Engine'
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Include in Airflow',
      value: true,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.includeInAirflow
    } // Boolean, true or false, default: true
  ]
  return settings
}

// Export

export function initExportEnumDropdownFilters(
  exportType: string | null,
  exportTool: string | null
) {
  const filterData: EditSetting[] = [
    {
      label: 'Export Type',
      value: exportType,
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportType')
    },
    {
      label: 'Export Tool',
      value: exportTool,
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportTool')
    }
  ]

  return filterData
}

export function exportCnTablesEditSettings(row: UIExportCnTables) {
  const rowData: EditSetting[] = [
    {
      label: 'Database',
      value: row.database,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.database,
      isRequired: true
    }, //Free-text, varchar(256), required
    {
      label: 'Table',
      value: row.table,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.table,
      isRequired: true
    }, // Free-text, varchar(256), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Export Type',
      value: mapDisplayValue('exportType', row.exportType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportType'),
      infoText: infoTexts.table.export.exportType
    }, // Enum mapping for 'Export Type', required
    {
      label: 'Export Tool',
      value: mapDisplayValue('exportTool', row.exportTool),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportTool'),
      infoText: infoTexts.table.export.exportTool
    }, // Enum mapping for 'Export Tool', required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Include in Airflow',
      value: row.includeInAirflow,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.includeInAirflow
    } // Boolean true or false, required (default value: true)
  ]

  return rowData
}

export function exportCardRenderSettings(table: UIExportTable) {
  const mainSettings: EditSetting[] = [
    {
      label: 'Connection',
      value: table.connection,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.connection
    }, // Read-only, required
    {
      label: 'Target Table',
      value: table.targetTable,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.targetTable
    }, // Read-only, required
    {
      label: 'Target Schema',
      value: table.targetSchema,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.targetSchema
    }, // Read-only, required

    {
      label: 'Database',
      value: table.database,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.database,
      isRequired: true
    }, // Free-text, varchar(256), required
    {
      label: 'Table',
      value: table.table,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.table,
      isRequired: true
    }, // Free-text, varchar(256), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Export Type',
      value: mapDisplayValue('exportType', table.exportType),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportType'),
      infoText: infoTexts.table.export.exportType
    }, // Enum mapping for 'Export Type', required
    {
      label: 'Export Tool',
      value: mapDisplayValue('exportTool', table.exportTool),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportTool'),
      infoText: infoTexts.table.export.exportTool
    }, // Enum mapping for 'Export Tool', required
    {
      label: 'Last update from Hive',
      value: table.lastUpdateFromHive,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.lastUpdateFromHive
    } // Read-only setting
  ]

  const exportOptions: EditSetting[] = [
    {
      label: 'Sqoop Options',
      value: table.sqoopOptions,
      type: SettingType.Textarea,
      maxChar: 1024,
      isConditionsMet: table.exportTool === ExportTool.Sqoop,
      infoText: infoTexts.table.export.sqoopOptions
    }, // Free-text, varchar(1024), active only if exportTool=sqoop
    {
      label: 'Truncate Target',
      value: table.truncateTarget,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.truncateTarget,
      isConditionsMet: table.exportType === ExportType.Full
    }, // Boolean, true or false, active only if exportType=full, required

    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'SQL Where Addition',
      value: table.sqlWhereAddition,
      type: SettingType.Textarea,
      maxChar: 1024,
      infoText: infoTexts.table.export.sqlWhereAddition
    }, // Free-text, varchar(1024)
    {
      label: 'Uppercase Columns',
      value: table.uppercaseColumns,
      type: SettingType.BooleanNumberOrAuto,
      infoText: infoTexts.table.export.uppercaseColumns
    }, // Read-only (meanwhile) or maybe IntegerFromOneOrAuto, required
    {
      label: 'Create Target Table Sql',
      value: table.createTargetTableSql,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.createTargetTableSql
    }, // Read-only
    {
      label: 'Force Create Temp Table',
      value: table.forceCreateTempTable,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.forceCreateTempTable
    }, // Boolean, true or false, required

    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Last Size',
      value: table.lastSize,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.lastSize
    }, // Read-only
    {
      label: 'Last Rows',
      value: table.lastRows,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.lastRows
    }, // Read-only
    {
      label: 'Last number of SQL Sessions',
      value: table.lastSqlSessions,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.lastSqlSessions
    } // Read-only
  ]

  const incrementalExports: EditSetting[] = [
    {
      label: 'Incremental Column',
      value: table.incrColumn,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.incrColumn,
      isConditionsMet: table.exportType === ExportType.Incremental
    }, // Free-text, varchar(256), active if exportType=incr
    {
      label: 'Incremental Validation Method',
      value: mapDisplayValue(
        'exportIncrValidationMethod',
        table.incrValidationMethod as string
      ),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportIncrValidationMethod'),
      infoText: infoTexts.table.export.incrValidationMethod,
      isConditionsMet: table.exportType === ExportType.Incremental
    }, // Enum list, active if exportType=incr
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Incremental Min Value',
      value: table.incrMinvalue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.incrMinvalue
    }, // Read-only
    {
      label: 'Incremental Max Value',
      value: table.incrMaxvalue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.incrMaxvalue
    }, // Read-only
    {
      label: 'Pending Min Value',
      value: table.incrMinvaluePending,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.incrMinvaluePending
    }, // Read-only
    {
      label: 'Pending Max Value',
      value: table.incrMaxvaluePending,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.incrMaxvaluePending
    } // Read-only
  ]

  const performance: EditSetting[] = [
    {
      label: 'SQL Sessions',
      value: table.sqlSessions,
      type: SettingType.IntegerFromOneOrAuto,
      maxInt: 127,
      infoText: infoTexts.table.export.sqlSessions
    }, // Integer, tinyint(4), -1 = Auto
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Hive Tez Container size (MB)',
      value: table.hiveContainerSize,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.table.export.hiveContainerSize
    } // Integer, bigint(20), value is MB
  ]

  const validation: EditSetting[] = [
    {
      label: 'Validate Export',
      value: table.validateExport,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.validateExport
    }, // Boolean, true or false, required
    {
      label: 'Validation Method',
      value: mapDisplayValue(
        'exportValidationMethod',
        table.validationMethod as string
      ),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportValidationMethod'),
      infoText: infoTexts.table.export.validationMethod
    }, // Enum mapping for 'Validation Method', required
    {
      label: 'Custom Query Target SQL',
      value: table.validationCustomQueryTargetSQL,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.table.export.validationCustomQueryTargetSQL,
      isConditionsMet:
        table.validationMethod === ExportValidationMethod.CustomQuery
    }, // Free-text, 64k, active if validationMethod=customQuery
    {
      label: 'Custom Query Hive SQL',
      value: table.validationCustomQueryHiveSQL,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.table.export.validationCustomQueryHiveSQL,
      isConditionsMet:
        table.validationMethod === ExportValidationMethod.CustomQuery
    }, // Free-text, 64k, active if validationMethod=customQuery
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Table Row Count',
      value: table.tableRowcount,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.tableRowcount
    }, // Read-only
    {
      label: 'Target Row Count',
      value: table.targetRowcount,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.targetRowcount
    }, // Read-only

    {
      label: 'Custom Query Target Value',
      value: table.validationCustomQueryTargetValue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.validationCustomQueryTargetValue,
      isConditionsMet:
        table.validationMethod === ExportValidationMethod.CustomQuery
    }, // Read-only
    {
      label: 'Custom Query Hive Value',
      value: table.validationCustomQueryHiveValue,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.validationCustomQueryHiveValue,
      isConditionsMet:
        table.validationMethod === ExportValidationMethod.CustomQuery
    } // Read-only
  ]

  const schedule: EditSetting[] = [
    {
      label: 'Airflow Priority',
      value: table.airflowPriority,
      type: SettingType.IntegerFromOneOrNull,
      maxInt: 127,
      infoText: infoTexts.table.export.airflowPriority
    }, // Integer, tinyint(4) (should not be string in API)
    {
      label: 'Include in Airflow',
      value: table.includeInAirflow,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.includeInAirflow
    }, // Boolean, true or false, required
    {
      label: 'Operator notes',
      value: table.operatorNotes,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.table.export.operatorNotes
    } // Free-text, 64k
  ]

  const exportCards = {
    mainSettings,
    exportOptions,
    incrementalExports,
    performance,
    validation,
    schedule
  }

  return exportCards
}

export function exportColumnRowDataEdit(row: ExportColumns) {
  const rowData: EditSetting[] = [
    {
      label: 'Column Name',
      value: row.columnName,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.columns.columnName
    }, // Read-only, required
    {
      label: 'Column Order',
      value: row.columnOrder,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.columns.columnOrder
    }, // Number for order in columns, preliminary readonly
    {
      label: 'Column Type',
      value: row.columnType,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.columns.columnType
    }, // Read-only
    {
      label: 'Target Column Name',
      value: row.targetColumnName,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.columns.targetColumnName
    }, // Free-text, varchar(256)
    {
      label: 'Target Column Type',
      value: row.targetColumnType,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.columns.targetColumnType
    }, // Free-text, varchar(256)
    {
      label: 'Last update from Hive',
      value: row.lastUpdateFromHive,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.columns.lastUpdateFromHive
    }, // Read-only, Timestamp, required
    {
      label: 'Include in Export',
      value: row.includeInExport,
      type: SettingType.Boolean,
      infoText: infoTexts.table.export.columns.includeInExport
    }, // Boolean, true or false boolean, required
    {
      label: 'Comment',
      value: row.comment,
      type: SettingType.Readonly,
      infoText: infoTexts.table.export.columns.comment
    }, // Free-text, 64k
    {
      label: 'Operator notes',
      value: row.operatorNotes,
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.table.export.columns.operatorNotes
    } // Free-text, 64k
  ]

  return rowData
}

export function initialCreateExportTableSettings(
  prefilledConnection: string | null
) {
  const settings: EditSetting[] = [
    {
      label: 'Connection',
      value: prefilledConnection,
      type: SettingType.DataReferenceRequired,
      maxChar: 256,
      infoText: infoTexts.table.export.connection,
      isRequired: true
    }, //Connections-dropdown, default selected connection, varchar(256), required
    {
      label: 'Target Table',
      value: null,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.targetTable,
      isRequired: true
    }, // Free-text, varchar(256), required
    {
      label: 'Target Schema',
      value: null,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.targetSchema,
      isRequired: true
    }, // Free-text, varchar(256), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Database',
      value: null,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.database,
      isRequired: true
    }, // Free-text, varchar(256), required
    {
      label: 'Table',
      value: null,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.table.export.table,
      isRequired: true
    }, // Free-text, varchar(256), required

    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Export Type',
      value: mapDisplayValue('exportType', ExportType.Full),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportType'),
      infoText: infoTexts.table.export.exportType
    }, // Enum mapping for 'Export Type'
    {
      label: 'Export Tool',
      value: mapDisplayValue('exportTool', ExportTool.Spark),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('exportTool'),
      infoText: infoTexts.table.export.exportTool
    }, // Enum mapping for 'Export Tool'
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Include in Airflow',
      value: true,
      type: SettingType.Boolean,
      infoText: infoTexts.table.import.includeInAirflow
    } // Boolean, true or false, default: true
  ]
  return settings
}

// Configuration

export function configGlobalCardRenderSettings(config: ConfigGlobal) {
  const airflowConfigData: EditSetting[] = [
    {
      label: 'AWS Instanceids',
      value: config.airflow_aws_instanceids,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.airflow_aws_instanceids,
      isHidden: config.airflow_aws_instanceids === null,
      isRequired: true
    }, //Free-text, varchar(256), required
    {
      label: 'AWS Pool to Instanceid',
      value: config.airflow_aws_pool_to_instanceid,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.airflow_aws_pool_to_instanceid,
      isHidden: config.airflow_aws_pool_to_instanceid === null
    }, // Boolean, true or false, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space

    {
      label: 'DAG Directory',
      value: config.airflow_dag_directory,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.airflow_dag_directory,
      isHidden: config.airflow_dag_directory === null,
      isRequired: true
    }, // Free-text, varchar (256), folder name, required
    {
      label: 'DAG File Group',
      value: config.airflow_dag_file_group,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.airflow_dag_file_group,
      isHidden: config.airflow_dag_file_group === null,
      isRequired: true
    }, // Free-text, varchar (256), group name, required
    {
      label: 'DAG File Permission',
      value: config.airflow_dag_file_permission,
      type: SettingType.TextTripletOctalValue,
      maxChar: 256,
      infoText: infoTexts.configuration.global.airflow_dag_file_permission,
      isHidden: config.airflow_dag_file_permission === null,
      isRequired: true
    }, // Free-text, varchar (256), Has to be a string with triplet-octal value, e.g. 342, required
    {
      label: 'DAG Staging Directory',
      value: config.airflow_dag_staging_directory,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.airflow_dag_staging_directory,
      isHidden: config.airflow_dag_staging_directory === null,
      isRequired: true
    }, // Free-text, varchar (256), folder name, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space

    {
      label: 'DBImport Command Path',
      value: config.airflow_dbimport_commandpath,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.airflow_dbimport_commandpath,
      isHidden: config.airflow_dbimport_commandpath === null,
      isRequired: true
    }, // Free-text, varchar (256), full command, required
    {
      label: 'Sudo User',
      value: config.airflow_sudo_user,
      type: SettingType.Text,
      maxChar: 64,
      infoText: infoTexts.configuration.global.airflow_sudo_user,
      isHidden: config.airflow_sudo_user === null,
      isRequired: true
    }, // Free-text, varchar (64), username, required
    {
      label: 'Create Pool with Task',
      value: config.airflow_create_pool_with_task,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.airflow_create_pool_with_task,
      isHidden: config.airflow_create_pool_with_task === null
    }, // Boolean, true or false, required
    {
      label: 'Default Pool Size',
      value: config.airflow_default_pool_size,
      type: SettingType.IntegerFromOne,
      infoText: infoTexts.configuration.global.airflow_default_pool_size,
      isHidden: config.airflow_default_pool_size === null,
      isRequired: true
    }, // Integer, from 1, required
    {
      label: 'Dummy Task Queue',
      value: config.airflow_dummy_task_queue,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.airflow_dummy_task_queue,
      isHidden: config.airflow_dummy_task_queue === null,
      isRequired: true
    }, // Free-text, varchar (256), required
    {
      label: 'Major Version',
      value: config.airflow_major_version,
      type: SettingType.IntegerOneOrTwo,
      infoText: infoTexts.configuration.global.airflow_major_version,
      isHidden: config.airflow_major_version === null
    }, // Integer, 1 or 2, required
    {
      label: 'Airflow URL',
      value: config.airflow_url,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.airflow_url,
      isHidden: config.airflow_url === null
    } // Free-text, varchar (256)
  ]

  const disableOperationsConfigData: EditSetting[] = [
    {
      label: 'Airflow Disable',
      value: config.airflow_disable,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.airflow_disable,
      isHidden: config.airflow_disable === null
    }, // Boolean, true or false, required
    {
      label: 'Export Start Disable',
      value: config.export_start_disable,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.export_start_disable,
      isHidden: config.export_start_disable === null
    }, // Boolean, true or false, required
    {
      label: 'Export Stage Disable',
      value: config.export_stage_disable,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.export_stage_disable,
      isHidden: config.export_stage_disable === null
    }, // Boolean, true or false, required
    {
      label: 'Import Start Disable',
      value: config.import_start_disable,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.import_start_disable,
      isHidden: config.import_start_disable === null
    }, // Boolean, true or false, required
    {
      label: 'Import Stage Disable',
      value: config.import_stage_disable,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.import_stage_disable,
      isHidden: config.import_stage_disable === null
    } // Boolean, true or false, required
  ]

  const miscConfigData: EditSetting[] = [
    {
      label: 'Timezone',
      value: config.timezone,
      type: SettingType.TimeZone,
      maxChar: 64,
      infoText: infoTexts.configuration.global.timezone,
      isHidden: config.timezone === null
    }, // Timezone, varchar(64), Use full text timezone, example Europe/Stockholm
    {
      label: 'Atlas Discovery Interval',
      value: config.atlas_discovery_interval,
      type: SettingType.IntegerFromOne,
      maxInt: 24,
      infoText: infoTexts.configuration.global.atlas_discovery_interval,
      isHidden: config.atlas_discovery_interval === null,
      isRequired: true
    } // Integer, 1-24, required
  ]

  const HDFSConfigData: EditSetting[] = [
    {
      label: 'Cluster Name',
      value: config.cluster_name,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.cluster_name,
      isHidden: config.cluster_name === null,
      isRequired: true
    }, // Free-text, varchar(256), required
    {
      label: 'Address',
      value: config.hdfs_address,
      type: SettingType.Text,
      maxChar: 64,
      infoText: infoTexts.configuration.global.hdfs_address,
      isHidden: config.hdfs_address === null,
      isRequired: true
    }, // Free-text, varchar(64), filesytem url, required
    {
      label: 'Base Directory',
      value: config.hdfs_basedir,
      type: SettingType.Text,
      maxChar: 64,
      infoText: infoTexts.configuration.global.hdfs_basedir,
      isHidden: config.hdfs_basedir === null,
      isRequired: true
    }, // Free-text, varchar(64), folder name, required
    {
      label: 'Blocksize',
      value: config.hdfs_blocksize,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.hdfs_blocksize,
      isHidden: config.hdfs_blocksize === null,
      isRequired: true
    } // Free-text, varchar(256), it is string but usually it is a bigint saved in it, required
  ]

  const sqlServersConfigData: EditSetting[] = [
    {
      label: 'Hive Acid with Clusteredby',
      value: config.hive_acid_with_clusteredby,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.hive_acid_with_clusteredby,
      isHidden: config.hive_acid_with_clusteredby === null
    }, // Boolean, true or false, required
    {
      label: 'Hive Insert Only Tables',
      value: config.hive_insert_only_tables,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.hive_insert_only_tables,
      isHidden: config.hive_insert_only_tables === null
    }, // Boolean, true or false, required
    {
      label: 'Hive Major Compact after Merge',
      value: config.hive_major_compact_after_merge,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.hive_major_compact_after_merge,
      isHidden: config.hive_major_compact_after_merge === null
    }, // Boolean, true or false, required
    {
      label: 'Hive Print Messages',
      value: config.hive_print_messages,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.hive_print_messages,
      isHidden: config.hive_print_messages === null
    }, // Boolean, true or false, required
    {
      label: 'Hive Remove Locks by force',
      value: config.hive_remove_locks_by_force,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.hive_remove_locks_by_force,
      isHidden: config.hive_remove_locks_by_force === null
    }, // Boolean, true or false, required
    {
      label: 'Hive Validate before execution',
      value: config.hive_validate_before_execution,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.hive_validate_before_execution,
      isHidden: config.hive_validate_before_execution === null
    }, // Boolean, true or false, required
    {
      label: 'Hive Validate Table',
      value: config.hive_validate_table,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.hive_validate_table,
      isHidden: config.hive_validate_table === null,
      isRequired: true
    }, // Free-text, varchar(256), table name, required
    {
      label: 'Impala Invalidate Metadata',
      value: config.impala_invalidate_metadata,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.impala_invalidate_metadata,
      isHidden: config.impala_invalidate_metadata === null
    } // Boolean, true or false, required
  ]

  const importAndExportConfigData: EditSetting[] = [
    {
      label: 'Import Columnname Delete',
      value: config.import_columnname_delete,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_columnname_delete,
      isHidden: config.import_columnname_delete === null,
      isRequired: true
    }, // Free-text, varchar (256), column name, required
    {
      label: 'Import Columnname Histtime',
      value: config.import_columnname_histtime,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_columnname_histtime,
      isHidden: config.import_columnname_histtime === null,
      isRequired: true
    }, // Free-text, varchar (256), column name, required
    {
      label: 'Import Columnname Import',
      value: config.import_columnname_import,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_columnname_import,
      isHidden: config.import_columnname_import === null,
      isRequired: true
    }, // Free-text, varchar (256), column name, required
    {
      label: 'Import Columnname Insert',
      value: config.import_columnname_insert,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_columnname_insert,
      isHidden: config.import_columnname_insert === null,
      isRequired: true
    }, // Free-text, varchar (256), column name, required
    {
      label: 'Import Columnname Iud',
      value: config.import_columnname_iud,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_columnname_iud,
      isHidden: config.import_columnname_iud === null,
      isRequired: true
    }, // Free-text, varchar (256), column name, required
    {
      label: 'Import Columnname Source',
      value: config.import_columnname_source,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_columnname_source,
      isHidden: config.import_columnname_source === null,
      isRequired: true
    }, // Free-text, varchar (256), column name, required
    {
      label: 'Import Columnname Update',
      value: config.import_columnname_update,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_columnname_update,
      isHidden: config.import_columnname_update === null,
      isRequired: true
    }, // Free-text, varchar (256), column name, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space

    {
      label: 'Import History Database',
      value: config.import_history_database,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_history_database,
      isHidden: config.import_history_database === null,
      isRequired: true
    }, // Free-text, varchar (256), database name, required
    {
      label: 'Import History Table',
      value: config.import_history_table,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_history_table,
      isHidden: config.import_history_table === null,
      isRequired: true
    }, // Free-text, varchar (256), table name, required

    {
      label: 'Import Staging Database',
      value: config.import_staging_database,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_staging_database,
      isHidden: config.import_staging_database === null,
      isRequired: true
    }, // Free-text, varchar (256), database name, required
    {
      label: 'Import Staging Table',
      value: config.import_staging_table,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_staging_table,
      isHidden: config.import_staging_table === null,
      isRequired: true
    }, // Free-text, varchar (256), table name, required

    {
      label: 'Import Work Database',
      value: config.import_work_database,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_work_database,
      isHidden: config.import_work_database === null,
      isRequired: true
    }, // Free-text, varchar (256), database name, required
    {
      label: 'Import Work Table',
      value: config.import_work_table,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.import_work_table,
      isHidden: config.import_work_table === null,
      isRequired: true
    }, // Free-text, varchar (256), table name, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Export Staging Database',
      value: config.export_staging_database,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.export_staging_database,
      isHidden: config.export_staging_database === null,
      isRequired: true
    }, // Free-text, varchar (256), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Import Process Empty',
      value: config.import_process_empty,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.import_process_empty,
      isHidden: config.import_process_empty === null
    } // Boolean, true or false, required
  ]

  const notificationsConfigData: EditSetting[] = [
    {
      label: 'Post Airflow Dag Operations',
      value: config.post_airflow_dag_operations,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.post_airflow_dag_operations,
      isHidden: config.post_airflow_dag_operations === null
    }, // Boolean, true or false, required
    {
      label: 'Post Data to AWS SNS',
      value: config.post_data_to_awssns,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.post_data_to_awssns,
      isHidden: config.post_data_to_awssns === null
    }, // Boolean, true or false, required
    {
      label: 'Post Data to AWS SNS Extended',
      value: config.post_data_to_awssns_extended,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.post_data_to_awssns_extended,
      isHidden: config.post_data_to_awssns_extended === null
    }, // Boolean, true or false, required

    {
      label: 'Post Data to Kafka',
      value: config.post_data_to_kafka,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.post_data_to_kafka,
      isHidden: config.post_data_to_kafka === null
    }, // Boolean, true or false, required
    {
      label: 'Post Data to Kafka Extended',
      value: config.post_data_to_kafka_extended,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.post_data_to_kafka_extended,
      isHidden: config.post_data_to_kafka_extended === null
    }, // Boolean, true or false, required
    {
      label: 'Post Data to Rest',
      value: config.post_data_to_rest,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.post_data_to_rest,
      isHidden: config.post_data_to_rest === null
    }, // Boolean, true or false, required
    {
      label: 'Post Data to Rest Extended',
      value: config.post_data_to_rest_extended,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.post_data_to_rest_extended,
      isHidden: config.post_data_to_rest_extended === null
    }, // Boolean, true or false, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Post Data to AWS SNS Topic',
      value: config.post_data_to_awssns_topic,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.post_data_to_awssns_topic,
      isHidden: config.post_data_to_awssns_topic === null,
      isRequired: true
    }, // Free-text, varchar (256), sns topic address, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Kafka Brokers',
      value: config.kafka_brokers,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.kafka_brokers,
      isHidden: config.kafka_brokers === null,
      isRequired: true
    }, // Free-text, varchar (256), comma separated list of servers and ports, required
    {
      label: 'Kafka Securityprotocol',
      value: config.kafka_securityprotocol,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.kafka_securityprotocol,
      isHidden: config.kafka_securityprotocol === null,
      isRequired: true
    }, // Free-text, varchar (256), required
    {
      label: 'Kafka Saslmechanism',
      value: config.kafka_saslmechanism,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.kafka_saslmechanism,
      isHidden: config.kafka_saslmechanism === null,
      isRequired: true
    }, // Free-text, varchar (256), required

    {
      label: 'Kafka Topic',
      value: config.kafka_topic,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.kafka_topic,
      isHidden: config.kafka_topic === null,
      isRequired: true
    }, // Free-text, varchar (256), required
    {
      label: 'Kafka Trustcafile',
      value: config.kafka_trustcafile,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.kafka_trustcafile,
      isHidden: config.kafka_trustcafile === null,
      isRequired: true
    }, // Free-text, varchar (256), filename, required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Rest Timeout',
      value: config.rest_timeout,
      type: SettingType.IntegerFromOne,
      infoText: infoTexts.configuration.global.rest_timeout,
      isHidden: config.rest_timeout === null,
      isRequired: true
    }, // Integer, from 1, int(11) required
    {
      label: 'Rest Trustcafile',
      value: config.rest_trustcafile,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.rest_trustcafile,
      isHidden: config.rest_trustcafile === null,
      isRequired: true
    }, // Free-text, varchar (256), filename, required
    {
      label: 'Rest Url',
      value: config.rest_url,
      type: SettingType.Text,
      maxChar: 256,
      infoText: infoTexts.configuration.global.rest_url,
      isHidden: config.rest_url === null,
      isRequired: true
    }, // Free-text, varchar (256), url, required
    {
      label: 'Rest Verify SSL',
      value: config.rest_verifyssl,
      type: SettingType.Boolean,
      infoText: infoTexts.configuration.global.rest_verifyssl,
      isHidden: config.rest_verifyssl === null
    } // Boolean, true or false, required
  ]

  const dbimportServersConfigData: EditSetting[] = [
    {
      label: 'Admin User',
      value: config.restserver_admin_user,
      type: SettingType.Text,
      maxChar: 255,
      infoText: infoTexts.configuration.global.restserver_admin_user,
      isHidden: config.restserver_admin_user === null,
      isRequired: true
    }, // Free-text, varchar (255), required
    {
      label: 'Authentication Method',
      value: mapDisplayValue(
        'restserver_authentication_method',
        config.restserver_authentication_method as string
      ),
      type: SettingType.Enum,
      enumOptions: getEnumOptions('restserver_authentication_method'),
      infoText: infoTexts.configuration.global.restserver_authentication_method,
      isHidden: config.restserver_authentication_method === null
    }, // Free-text, varchar (256), filesytem url, required

    {
      label: 'Token TTL',
      value: config.restserver_token_ttl,
      type: SettingType.IntegerFromOne,
      infoText: infoTexts.configuration.global.restserver_token_ttl,
      isHidden: config.restserver_token_ttl === null,
      isRequired: true
    } // Integer, from 1, int(11), required
  ]

  const performanceConfigData: EditSetting[] = [
    {
      label: 'Import Default Sessions',
      value: config.import_default_sessions,
      type: SettingType.IntegerFromOne,
      infoText: infoTexts.configuration.global.import_default_sessions,
      isHidden: config.import_default_sessions === null,
      isRequired: true
    }, // Integer, from 1, int(11), required
    {
      label: 'Import Max Sessions',
      value: config.import_max_sessions,
      type: SettingType.IntegerFromOne,
      infoText: infoTexts.configuration.global.import_max_sessions,
      isHidden: config.import_max_sessions === null,
      isRequired: true
    }, // Integer, from 1, int(11), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Export Default Sessions',
      value: config.export_default_sessions,
      type: SettingType.IntegerFromOne,
      infoText: infoTexts.configuration.global.export_default_sessions,
      isHidden: config.export_default_sessions === null,
      isRequired: true
    }, // Integer, from 1, int(11), required
    {
      label: 'Export Max Sessions',
      value: config.export_max_sessions,
      type: SettingType.IntegerFromOne,
      infoText: infoTexts.configuration.global.export_max_sessions,
      isHidden: config.export_max_sessions === null,
      isRequired: true
    }, // Integer, from 1, int(11), required
    {
      label: '',
      value: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      label: 'Spark Max Executors',
      value: config.spark_max_executors,
      type: SettingType.IntegerFromOne,
      infoText: infoTexts.configuration.global.spark_max_executors,
      isHidden: config.spark_max_executors === null,
      isRequired: true
    } // Integer, from 1, int(11), required
  ]

  const configCards = {
    airflowConfigData,
    disableOperationsConfigData,
    miscConfigData,
    HDFSConfigData,
    sqlServersConfigData,
    importAndExportConfigData,
    notificationsConfigData,
    dbimportServersConfigData,
    performanceConfigData
  }

  return configCards
}

export function JDBCdriversRowDataEdit(row: JDBCdrivers) {
  const rowData: EditSetting[] = [
    {
      label: 'Driver',
      value: row.driver,
      type: SettingType.Text,
      maxChar: 128,
      infoText: infoTexts.configuration.jdbcDrivers.driver,
      isRequired: true
    }, // Free-text, varchar(128), required
    {
      label: 'Class Path',
      value: row.classpath,
      type: SettingType.Text,
      maxChar: 255,
      infoText: infoTexts.configuration.jdbcDrivers.classpath,
      isRequired: true
    } // Free-text, varchar(255), required
  ]

  return rowData
}

// Bulk Edit

export const bulkImportFieldsData: BulkField<UiDbTable>[] = [
  {
    key: 'importPhaseType',
    label: 'Import Type',
    type: SettingType.Enum,
    enumOptions: getEnumOptions('importPhaseType'),
    infoText: infoTexts.table.import.importPhaseType
  }, // Enum mapping for 'Import Type'
  {
    key: 'importTool',
    label: 'Import Tool',
    type: SettingType.Enum,
    enumOptions: getEnumOptions('importTool'),
    infoText: infoTexts.table.import.importTool
  }, // Enum mapping for 'Import Tool'
  {
    key: 'etlPhaseType',
    label: 'ETL Type',
    type: SettingType.Enum,
    enumOptions: getEnumOptions('etlPhaseType'),
    infoText: infoTexts.table.import.etlPhaseType
  }, // Enum mapping for 'ETL Type'
  {
    key: 'etlEngine',
    label: 'ETL Engine',
    type: SettingType.Enum,
    enumOptions: getEnumOptions('etlEngine'),
    infoText: infoTexts.table.import.etlEngine
  }, // Enum mapping for 'ETL Engine'
  {
    key: 'groupingspace',
    label: '',
    type: SettingType.GroupingSpace
  }, // Layout space
  {
    key: 'includeInAirflow',
    label: 'Include in Airflow',
    type: SettingType.Boolean,
    infoText: infoTexts.table.import.includeInAirflow
  }, // Boolean, true or false
  {
    key: 'groupingspace',
    label: '',
    type: SettingType.GroupingSpace
  }, // Layout space
  {
    key: 'operatorNotes',
    label: 'Operator notes',
    type: SettingType.Textarea,
    maxChar: 64000,
    infoText: infoTexts.airflow.import.operatorNotes
  }, // Free-text (64k)
  {
    key: 'groupingspace',
    label: '',
    type: SettingType.GroupingSpace
  } // Layout space
]

export const bulkExportFieldsData: BulkField<UIExportCnTables>[] = [
  {
    key: 'exportType',
    label: 'Export Type',
    type: SettingType.Enum,
    enumOptions: getEnumOptions('exportType'),
    infoText: infoTexts.table.export.exportType
  }, // Enum mapping for 'Export Type'
  {
    key: 'exportTool',
    label: 'Export Tool',
    type: SettingType.Enum,
    enumOptions: getEnumOptions('exportTool'),
    infoText: infoTexts.table.export.exportTool
  }, // Enum mapping for 'Export Tool'
  {
    key: 'groupingspace',
    label: '',
    type: SettingType.GroupingSpace
  }, // Layout space
  {
    key: 'includeInAirflow',
    label: 'Include in Airflow',
    type: SettingType.Boolean,
    infoText: infoTexts.table.import.includeInAirflow
  }, // Boolean, true or false, default: true
  {
    key: 'groupingspace',
    label: '',
    type: SettingType.GroupingSpace
  }, // Layout space
  {
    key: 'operatorNotes',
    label: 'Operator notes',
    type: SettingType.Textarea,
    maxChar: 64000,
    infoText: infoTexts.airflow.export.operatorNotes
  }, // Free-text (64k)
  {
    key: 'groupingspace',
    label: '',
    type: SettingType.GroupingSpace
  } // Layout space
]

export function bulkAirflowDagFieldsData(
  airflowType: 'import' | 'export' | 'custom'
  // dagData: ImportAirflowDAG | ExportAirflowDAG | CustomAirflowDAG
) {
  const bulkAirflowDagFieldsData: BulkField<UiBulkAirflowDAG>[] = [
    {
      key: 'autoRegenerateDag',
      label: 'Auto Regenerate DAG',
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].autoRegenerateDag
    }, // Boolean, if not set pre-set default value: 1, 1 = The DAG will be auto regenerated by manage command, required
    {
      key: 'scheduleInterval',
      label: 'Schedule Interval',
      type: SettingType.Text,
      maxChar: 128,
      infoText: infoTexts.airflow[airflowType].scheduleInterval
    }, // Free-text, Time to execute DAG, varchar(128), required?
    {
      key: 'groupingspace',
      label: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      key: 'timezone',
      label: 'Timezone',
      type: SettingType.TimeZone,
      maxChar: 64,
      infoText: infoTexts.airflow[airflowType].timezone
    }, // Timezone,, varchar(64), used for schedule_interval column. Use full text timezone, example Europe/Stockholm
    {
      key: 'slaWarningTime',
      label: 'Sla Warning Time',
      type: SettingType.Time,
      infoText: infoTexts.airflow[airflowType].slaWarningTime
    }, // Time, Maximum time this DAG should run before Airflow triggers a SLA miss
    {
      key: 'groupingspace',
      label: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      key: 'concurrency',
      label: 'Concurrency',
      maxInt: 127,
      type: SettingType.IntegerFromOneOrNull,
      infoText: infoTexts.airflow[airflowType].concurrency
    }, // Integer, tinyint(4), Set the max Integer of concurrent tasks in the DAG while executing. Overrides the default value specified in Airflow configuration
    {
      key: 'groupingspace',
      label: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      key: 'email',
      label: 'Email',
      type: SettingType.Email,
      maxChar: 256,
      infoText: infoTexts.airflow[airflowType].email
      // isConditionsMet:
      //   dagData.emailOnRetries === true || dagData.emailOnFailure === true
    }, // Free-text, varchar(256), Email to send message to in case email_on_retry or email_on_failure is set to True
    {
      key: 'emailOnFailure',
      label: 'Email on Failure',
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].emailOnFailure
    }, // Boolean, if not set pre-set default value: false, Send Email on failures, required
    {
      key: 'emailOnRetries',
      label: 'Email on Retries',
      type: SettingType.Boolean,
      infoText: infoTexts.airflow[airflowType].emailOnRetries
    }, // Boolean, if not set pre-set default value: false, Send Email on retries, required
    {
      key: 'groupingspace',
      label: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      key: 'sudoUser',
      label: 'Sudo User',
      type: SettingType.Text,
      maxChar: 64,
      infoText: infoTexts.airflow[airflowType].sudoUser
    }, // Free-text, varchar(64), All tasks in DAG will use this user for sudo instead of default
    {
      key: 'groupingspace',
      label: '',
      type: SettingType.GroupingSpace
    }, // Layout space
    {
      key: 'operatorNotes',
      label: 'Operator notes',
      type: SettingType.Textarea,
      maxChar: 64000,
      infoText: infoTexts.airflow[airflowType].operatorNotes
    }, // Free-text (64k)
    {
      key: 'groupingspace',
      label: '',
      type: SettingType.GroupingSpace
    } // Layout space
  ]
  return bulkAirflowDagFieldsData
}
